"""Initialize a new YOLO Developer project."""

from __future__ import annotations

import re
import subprocess
import sys
from pathlib import Path

from rich.console import Console
from rich.panel import Panel
from rich.table import Table

from yolo_developer.config import (
    LLM_BEST_MODEL_DEFAULT,
    LLM_CHEAP_MODEL_DEFAULT,
    LLM_PREMIUM_MODEL_DEFAULT,
)
from yolo_developer.config.schema import BrownfieldConfig
from yolo_developer.scanner import ScannerManager

console = Console()

# Regex to extract base package name from dependency string
# Handles: package, package>=1.0, package==1.0, package~=1.0, package[extra], etc.
PACKAGE_NAME_PATTERN = re.compile(r"^([a-zA-Z0-9][-a-zA-Z0-9_.]*)")


def get_git_config(key: str) -> str:
    """Get a git config value.

    Args:
        key: The git config key to retrieve (e.g., "user.name", "user.email").

    Returns:
        The config value, or empty string if not found or on error.
    """
    try:
        result = subprocess.run(
            ["git", "config", "--get", key],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return ""


# yolo.yaml template with sensible defaults and comments
YOLO_YAML_TEMPLATE = """# YOLO Developer Configuration
# Generated by `yolo init`
# Documentation: https://github.com/anthropics/yolo-developer

# Project name (required)
project_name: {project_name}

# LLM Provider Configuration
llm:
  # Model for routine, low-complexity tasks
  cheap_model: {llm_cheap_model}

  # Model for complex reasoning tasks
  premium_model: {llm_premium_model}

  # Model for critical decisions requiring highest quality
  best_model: {llm_best_model}

  # API keys should be set via environment variables:
  # - YOLO_LLM__OPENAI__API_KEY
  # - YOLO_LLM__ANTHROPIC_API_KEY

# Quality Gate Configuration
quality:
  # Minimum test coverage ratio (0.0-1.0)
  test_coverage_threshold: 0.80

  # Minimum confidence score (0.0-1.0) for deployment approval
  confidence_threshold: 0.90

  # Seed quality thresholds
  seed_thresholds:
    overall: 0.70
    ambiguity: 0.60
    sop: 0.80

  # Path patterns that require 100% test coverage
  critical_paths:
    - orchestrator/
    - gates/
    - agents/

# Memory & Storage Configuration
memory:
  # Directory path for persisting memory data
  persist_path: .yolo/memory

  # Vector store backend (chromadb)
  vector_store_type: chromadb

  # Graph store backend (json for MVP, neo4j optional)
  graph_store_type: json
"""

# PEP 621 compliant pyproject.toml template
PYPROJECT_TEMPLATE = """[project]
name = "{name}"
version = "0.1.0"
description = "Autonomous multi-agent AI development system using BMad Method"
readme = "README.md"
requires-python = ">=3.10"
license = {{text = "MIT"}}
authors = [
    {{name = "{author}", email = "{email}"}}
]
keywords = ["ai", "agents", "development", "automation"]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]

dependencies = [
    "langgraph>=1.0.5",
    "langchain-core",
    "langchain-anthropic",
    "langchain-openai",
    "chromadb>=1.2.0",
    "typer",
    "rich",
    "pydantic>=2.0.0",
    "pydantic-settings",
    "litellm",
    "tenacity",
    "structlog",
    "pyyaml",
    "python-dotenv",
    "fastmcp>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest",
    "pytest-asyncio",
    "pytest-cov",
    "ruff",
    "mypy",
    "langsmith",
]

[project.scripts]
yolo = "yolo_developer.cli.main:app"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/yolo_developer"]

[tool.ruff]
line-length = 100
target-version = "py310"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "UP"]

[tool.mypy]
python_version = "3.10"
strict = true
warn_return_any = true
warn_unused_configs = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
"""

README_TEMPLATE = """# {name}

Autonomous multi-agent AI development system using BMad Method.

## Installation

```bash
uv sync
```

## Usage

```bash
yolo --help
```

## Development

```bash
uv sync --all-extras
uv run pytest
```
"""


def validate_python_version() -> bool:
    """Validate Python version is >= 3.10."""
    major, minor = sys.version_info[:2]
    if major < 3 or (major == 3 and minor < 10):
        console.print(f"[red]Error: Python 3.10+ required. Found {major}.{minor}[/red]")
        return False
    return True


def create_directory_structure(project_path: Path) -> None:
    """Create the complete directory structure for YOLO Developer per architecture spec."""
    # Source modules per architecture specification
    source_directories = [
        "src/yolo_developer/cli/commands",
        "src/yolo_developer/sdk",
        "src/yolo_developer/mcp",
        "src/yolo_developer/agents/prompts",  # agents with prompts subdirectory
        "src/yolo_developer/orchestrator",
        "src/yolo_developer/memory",
        "src/yolo_developer/gates/gates",  # gates with gates subdirectory for implementations
        "src/yolo_developer/seed",
        "src/yolo_developer/llm",
        "src/yolo_developer/audit",
        "src/yolo_developer/config",
        "src/yolo_developer/utils",
    ]

    # Test directories per architecture specification
    test_directories = [
        "tests/unit/agents",
        "tests/unit/gates",
        "tests/unit/memory",
        "tests/unit/seed",
        "tests/unit/config",
        "tests/integration",
        "tests/e2e",
        "tests/fixtures/seeds",
        "tests/fixtures/states",
    ]

    directories = source_directories + test_directories

    # Collect all Python package directories
    python_package_dirs: set[Path] = set()

    for dir_path in directories:
        full_path = project_path / dir_path
        full_path.mkdir(parents=True, exist_ok=True)

        # Collect all parent directories that should be Python packages
        if dir_path.startswith("src/") or dir_path.startswith("tests/"):
            # Walk from the deepest directory up to src/ or tests/
            current = full_path
            while current != project_path:
                rel_path = current.relative_to(project_path)
                rel_str = str(rel_path)
                # Include tests/ directory itself and all src/yolo_developer/... directories
                if rel_str == "tests" or rel_str.startswith("tests/") or rel_str.startswith("src/"):
                    python_package_dirs.add(current)
                current = current.parent

    # Create __init__.py in all Python package directories
    for pkg_dir in python_package_dirs:
        init_file = pkg_dir / "__init__.py"
        if not init_file.exists():
            init_file.write_text('"""Package."""\n')

    # Create .gitkeep files in empty fixture directories to preserve them in git
    gitkeep_dirs = [
        project_path / "tests" / "fixtures" / "seeds",
        project_path / "tests" / "fixtures" / "states",
    ]
    for gitkeep_dir in gitkeep_dirs:
        gitkeep_file = gitkeep_dir / ".gitkeep"
        if not gitkeep_file.exists():
            gitkeep_file.touch()


def create_pyproject_toml(
    project_path: Path,
    name: str,
    author: str,
    email: str,
) -> Path:
    """Create pyproject.toml from template."""
    content = PYPROJECT_TEMPLATE.format(
        name=name,
        author=author,
        email=email,
    )
    pyproject_path = project_path / "pyproject.toml"
    pyproject_path.write_text(content)
    return pyproject_path


def create_readme(project_path: Path, name: str) -> None:
    """Create README.md."""
    content = README_TEMPLATE.format(name=name)
    readme_path = project_path / "README.md"
    readme_path.write_text(content)


def create_py_typed(project_path: Path) -> None:
    """Create py.typed marker for PEP 561 compliance."""
    py_typed_path = project_path / "src" / "yolo_developer" / "py.typed"
    py_typed_path.touch()


def create_conftest(project_path: Path) -> None:
    """Create pytest conftest.py with initial configuration."""
    conftest_content = '''"""Pytest configuration and shared fixtures."""

from __future__ import annotations

import pytest  # noqa: F401


# Placeholder for shared fixtures
# Add fixtures here as needed during implementation
'''
    conftest_path = project_path / "tests" / "conftest.py"
    if not conftest_path.exists():
        conftest_path.write_text(conftest_content)


def create_mocks_stub(project_path: Path) -> None:
    """Create tests/fixtures/mocks.py stub file for LLM mocking."""
    mocks_content = '''"""Mock objects for testing LLM and external services."""

from __future__ import annotations

from typing import Any  # noqa: F401


class MockLLMResponse:
    """Mock response from LLM calls."""

    def __init__(self, content: str) -> None:
        self.content = content


# Add more mocks as needed during implementation
'''
    mocks_path = project_path / "tests" / "fixtures" / "mocks.py"
    if not mocks_path.exists():
        mocks_path.write_text(mocks_content)


def run_uv_sync(project_path: Path) -> bool:
    """Run uv sync to install dependencies."""
    try:
        subprocess.run(
            ["uv", "sync", "--all-extras"],
            cwd=project_path,
            capture_output=True,
            text=True,
            check=True,
        )
        return True
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Error running uv sync: {e.stderr}[/red]")
        return False
    except FileNotFoundError:
        console.print(
            "[yellow]Warning: uv not found. Run 'uv sync' manually after installation.[/yellow]"
        )
        return True  # Don't fail if uv is not installed


def create_yolo_yaml(project_path: Path, project_name: str, overwrite: bool = False) -> bool:
    """Create yolo.yaml configuration file with sensible defaults.

    Args:
        project_path: Path to the project directory.
        project_name: Name of the project.
        overwrite: If False and yolo.yaml exists, skip creation and return False.

    Returns:
        True if file was created/updated, False if skipped due to existing file.
    """
    yolo_yaml_path = project_path / "yolo.yaml"

    if yolo_yaml_path.exists() and not overwrite:
        console.print(
            "[yellow]yolo.yaml already exists, skipping. "
            "Use a new project or manually update configuration.[/yellow]"
        )
        return False

    content = YOLO_YAML_TEMPLATE.format(
        project_name=project_name,
        llm_cheap_model=LLM_CHEAP_MODEL_DEFAULT,
        llm_premium_model=LLM_PREMIUM_MODEL_DEFAULT,
        llm_best_model=LLM_BEST_MODEL_DEFAULT,
    )
    yolo_yaml_path.write_text(content)
    return True


def _extract_package_name(dep: str) -> str:
    """Extract base package name from a dependency string.

    Handles various formats:
    - package
    - package>=1.0.0
    - package==1.0.0
    - package~=1.0
    - package<2.0
    - package!=1.0
    - package[extra]>=1.0

    Args:
        dep: Dependency string from pyproject.toml.

    Returns:
        Lowercase base package name.
    """
    match = PACKAGE_NAME_PATTERN.match(dep.strip())
    if match:
        return match.group(1).lower()
    # Fallback: return the whole string lowercased if no match
    return dep.strip().lower()


def merge_pyproject_dependencies(project_path: Path) -> None:
    """Merge YOLO dependencies into existing pyproject.toml.

    For brownfield projects, this adds YOLO dependencies without
    overwriting existing configuration. Uses regex-based parsing
    for robust handling of various dependency formats.

    Args:
        project_path: Path to the project directory.
    """
    pyproject_path = project_path / "pyproject.toml"

    try:
        import tomllib
    except ImportError:
        import tomli as tomllib

    # Read existing pyproject.toml
    content = pyproject_path.read_text()
    existing = tomllib.loads(content)

    # YOLO required dependencies
    yolo_deps = [
        "langgraph>=1.0.5",
        "langchain-core",
        "langchain-anthropic",
        "langchain-openai",
        "chromadb>=1.2.0",
        "typer",
        "rich",
        "pydantic>=2.0.0",
        "pydantic-settings",
        "litellm",
        "tenacity",
        "structlog",
        "pyyaml",
        "python-dotenv",
        "fastmcp>=2.0.0",
    ]

    # Get existing dependencies
    existing_deps = existing.get("project", {}).get("dependencies", [])

    # Extract base package names using robust regex parsing
    existing_base_names = {_extract_package_name(d) for d in existing_deps}

    # Filter YOLO deps to only those not already present
    new_deps = [d for d in yolo_deps if _extract_package_name(d) not in existing_base_names]

    if not new_deps:
        console.print("[green]All YOLO dependencies already present.[/green]")
        return

    # Use regex-based approach to find and modify dependencies array
    # This handles various formatting styles more robustly
    deps_pattern = re.compile(
        r"(dependencies\s*=\s*\[)",  # Match "dependencies = [" with flexible whitespace
        re.MULTILINE,
    )

    match = deps_pattern.search(content)
    if match:
        # Insert new deps after the opening bracket
        insert_text = "\n".join(f'    "{d}",' for d in new_deps)
        insert_pos = match.end()
        content = content[:insert_pos] + "\n" + insert_text + content[insert_pos:]
    else:
        # No dependencies section found, add one after [project]
        project_pattern = re.compile(r"(\[project\])", re.MULTILINE)
        project_match = project_pattern.search(content)

        if project_match:
            # Find the next section or end of file
            next_section_pattern = re.compile(r"\n\[(?!project\.)", re.MULTILINE)
            next_match = next_section_pattern.search(content, project_match.end())
            insert_pos = next_match.start() if next_match else len(content)

            deps_text = "\ndependencies = [\n"
            deps_text += "\n".join(f'    "{d}",' for d in yolo_deps)
            deps_text += "\n]\n"
            content = content[:insert_pos] + deps_text + content[insert_pos:]
        else:
            console.print(
                "[yellow]Warning: Could not find [project] section in pyproject.toml. "
                "Please add YOLO dependencies manually.[/yellow]"
            )
            return

    pyproject_path.write_text(content)
    console.print(f"[green]Added {len(new_deps)} YOLO dependencies to pyproject.toml[/green]")


def init_command(
    path: str | None = None,
    name: str | None = None,
    author: str | None = None,
    email: str | None = None,
    interactive: bool = False,
    no_input: bool = False,
    existing: bool = False,
    scan_only: bool = False,
    non_interactive: bool = False,
    hint: str | None = None,
) -> None:
    """Initialize a new YOLO Developer project.

    Args:
        path: Directory to initialize the project in. Defaults to current directory.
        name: Project name. Defaults to directory name.
        author: Author name for pyproject.toml.
        email: Author email for pyproject.toml.
        interactive: If True, prompt for project details interactively.
        no_input: If True, use all defaults without prompting.
        existing: If True, add YOLO to an existing project (brownfield mode).
        scan_only: If True, scan project without making changes.
        non_interactive: If True, skip all prompts during scanning.
        hint: Optional hint about project type for scanning.
    """
    import typer

    # Validate Python version
    if not validate_python_version():
        raise SystemExit(1)

    # Resolve project path
    project_path = Path(path) if path else Path.cwd()
    project_path = project_path.resolve()

    # Create directory if it doesn't exist (greenfield only)
    if not existing:
        project_path.mkdir(parents=True, exist_ok=True)

    # Get defaults from git config
    git_user_name = get_git_config("user.name")
    git_user_email = get_git_config("user.email")

    if non_interactive:
        interactive = False
        no_input = True

    # Determine project name
    default_name = project_path.name
    if name:
        project_name = name
    elif interactive and not no_input:
        project_name = typer.prompt("Project name", default=default_name)
    else:
        project_name = default_name

    # Determine author info
    default_author = git_user_name or "Developer"
    if author:
        author_name = author
    elif interactive and not no_input:
        author_name = typer.prompt("Author name", default=default_author)
    else:
        author_name = git_user_name or "YOLO Developer"

    default_email = git_user_email or "dev@example.com"
    if email:
        author_email = email
    elif interactive and not no_input:
        author_email = typer.prompt("Author email", default=default_email)
    else:
        author_email = git_user_email or "dev@example.com"

    console.print(
        Panel(
            f"Initializing YOLO Developer project: [bold]{project_name}[/bold]"
            + (" (brownfield mode)" if existing else ""),
            title="YOLO Init",
            border_style="blue",
        )
    )

    if existing:
        # Brownfield mode: scan and add YOLO to existing project
        brownfield_config = BrownfieldConfig()
        _run_brownfield_scan(
            project_path=project_path,
            project_name=project_name,
            interactive=interactive,
            scan_only=scan_only,
            hint=hint,
            config=brownfield_config,
        )
        if scan_only:
            return

        pyproject_path = project_path / "pyproject.toml"
        if pyproject_path.exists():
            console.print("[blue]Adding YOLO dependencies to existing project...[/blue]")
            merge_pyproject_dependencies(project_path)
        else:
            console.print(
                "[yellow]No pyproject.toml found. Skipping dependency merge.[/yellow]"
            )

        # Create yolo.yaml (skip if already exists in brownfield mode)
        console.print("[blue]Checking yolo.yaml configuration...[/blue]")
        create_yolo_yaml(project_path, project_name, overwrite=False)

    else:
        # Greenfield mode: create new project
        # Create directory structure
        console.print("[blue]Creating directory structure...[/blue]")
        create_directory_structure(project_path)

        # Create pyproject.toml
        console.print("[blue]Creating pyproject.toml...[/blue]")
        create_pyproject_toml(project_path, project_name, author_name, author_email)

        # Create README
        console.print("[blue]Creating README.md...[/blue]")
        create_readme(project_path, project_name)

        # Create py.typed marker
        console.print("[blue]Creating py.typed marker...[/blue]")
        create_py_typed(project_path)

        # Create pytest conftest.py
        console.print("[blue]Creating pytest configuration...[/blue]")
        create_conftest(project_path)

        # Create mocks stub
        console.print("[blue]Creating test fixtures...[/blue]")
        create_mocks_stub(project_path)

        # Create yolo.yaml (overwrite allowed in greenfield mode)
        console.print("[blue]Creating yolo.yaml configuration...[/blue]")
        create_yolo_yaml(project_path, project_name, overwrite=True)

    # Run uv sync
    console.print("[blue]Installing dependencies with uv...[/blue]")
    if run_uv_sync(project_path):
        console.print("[green]Dependencies installed successfully![/green]")
    else:
        console.print("[yellow]Please run 'uv sync' manually.[/yellow]")

    console.print(
        Panel(
            f"[green]Project initialized successfully at:[/green]\n{project_path}\n\n"
            f"[blue]Next steps:[/blue]\n"
            f"  cd {project_path}\n"
            f"  yolo --help",
            title="Success",
            border_style="green",
        )
    )


def _run_brownfield_scan(
    project_path: Path,
    project_name: str,
    interactive: bool,
    scan_only: bool,
    hint: str | None,
    config: BrownfieldConfig,
) -> "ProjectContext | None":
    console.print("[blue]Scanning existing project...[/blue]")
    manager = ScannerManager()
    report = manager.scan(
        project_path=project_path,
        scan_depth=config.scan_depth,
        exclude_patterns=config.exclude_patterns,
        max_files=config.max_files_to_analyze,
        include_git_history=config.include_git_history,
        hint=hint,
    )
    _print_scan_report(report)

    if scan_only:
        console.print("[green]Scan complete (no changes made).[/green]")
        return None

    context = manager.build_project_context(
        report=report,
        project_name=project_name,
        interactive=interactive and config.interactive,
        console=console,
    )
    output_path = manager.write_project_context(project_path, context)
    console.print(f"[green]Generated project context:[/green] {output_path}")
    return context


def _print_scan_report(report) -> None:
    table = Table(title="Brownfield Scan Summary")
    table.add_column("Finding")
    table.add_column("Value")
    table.add_column("Confidence", justify="right")

    for finding in report.findings:
        if finding.key in {"docs", "git", "conventions"}:
            continue
        table.add_row(finding.key, str(finding.value), f"{finding.confidence:.0%}")

    console.print(table)

    if report.suggestions:
        console.print("[yellow]Suggestions:[/yellow]")
        for suggestion in report.suggestions:
            console.print(f"  - {suggestion}")
