"""Initialize a new YOLO Developer project."""

from __future__ import annotations

import re
import subprocess
import sys
from pathlib import Path

import structlog
from rich.console import Console
from rich.panel import Panel
from rich.table import Table

from yolo_developer.config import (
    LLM_BEST_MODEL_DEFAULT,
    LLM_CHEAP_MODEL_DEFAULT,
    LLM_PREMIUM_MODEL_DEFAULT,
)
from yolo_developer.config.schema import BrownfieldConfig
from yolo_developer.scanner import ScannerManager

console = Console()
logger = structlog.get_logger(__name__)

# Regex to extract base package name from dependency string
# Handles: package, package>=1.0, package==1.0, package~=1.0, package[extra], etc.
PACKAGE_NAME_PATTERN = re.compile(r"^([a-zA-Z0-9][-a-zA-Z0-9_.]*)")


def get_git_config(key: str) -> str:
    """Get a git config value.

    Args:
        key: The git config key to retrieve (e.g., "user.name", "user.email").

    Returns:
        The config value, or empty string if not found or on error.
    """
    try:
        result = subprocess.run(
            ["git", "config", "--get", key],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return ""


def check_git_initialized(path: Path | None = None) -> bool:
    """Check if the given path is inside a git repository.

    Uses `git rev-parse --git-dir` to determine if git is initialized.

    Args:
        path: Directory to check. Defaults to current working directory.

    Returns:
        True if the path is inside a git repository, False otherwise.
    """
    cwd = str(path) if path else None
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            capture_output=True,
            text=True,
            check=True,
            cwd=cwd,
        )
        return bool(result.stdout.strip())
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def get_git_remotes(path: Path | None = None) -> dict[str, str]:
    """Get all configured git remotes for the repository.

    Uses `git remote -v` to retrieve remote URLs.

    Args:
        path: Directory to check. Defaults to current working directory.

    Returns:
        Dictionary mapping remote names to their fetch URLs.
        Empty dict if not a git repo or no remotes configured.
    """
    cwd = str(path) if path else None
    try:
        result = subprocess.run(
            ["git", "remote", "-v"],
            capture_output=True,
            text=True,
            check=True,
            cwd=cwd,
        )
        remotes: dict[str, str] = {}
        for line in result.stdout.strip().split("\n"):
            if not line:
                continue
            # Format: "origin\thttps://github.com/user/repo.git (fetch)"
            parts = line.split()
            if len(parts) >= 2 and "(fetch)" in line:
                remote_name = parts[0]
                remote_url = parts[1]
                remotes[remote_name] = remote_url
        return remotes
    except (subprocess.CalledProcessError, FileNotFoundError):
        return {}


# yolo.yaml template with sensible defaults and comments
YOLO_YAML_TEMPLATE = """# YOLO Developer Configuration
# Generated by `yolo init`
# Documentation: https://github.com/anthropics/yolo-developer

# Project name (required)
project_name: {project_name}

# LLM Provider Configuration
llm:
  # Model for routine, low-complexity tasks
  cheap_model: {llm_cheap_model}

  # Model for complex reasoning tasks
  premium_model: {llm_premium_model}

  # Model for critical decisions requiring highest quality
  best_model: {llm_best_model}

  # API keys should be set via environment variables:
  # - YOLO_LLM__OPENAI__API_KEY
  # - YOLO_LLM__ANTHROPIC_API_KEY
  # For local development only, you can set them here with:
  # openai:
  #   api_key: sk-...
  # anthropic_api_key: sk-ant-...

# Quality Gate Configuration
quality:
  # Minimum test coverage ratio (0.0-1.0)
  test_coverage_threshold: 0.80

  # Minimum confidence score (0.0-1.0) for deployment approval
  confidence_threshold: 0.90

  # Seed quality thresholds
  seed_thresholds:
    overall: 0.70
    ambiguity: 0.60
    sop: 0.80

  # Path patterns that require 100% test coverage
  critical_paths:
    - orchestrator/
    - gates/
    - agents/

# Memory & Storage Configuration
memory:
  # Directory path for persisting memory data
  persist_path: .yolo/memory

  # Vector store backend (chromadb)
  vector_store_type: chromadb

  # Graph store backend (json for MVP, neo4j optional)
  graph_store_type: json
"""

# PEP 621 compliant pyproject.toml template
PYPROJECT_TEMPLATE = """[project]
name = "{name}"
version = "0.1.0"
description = "Autonomous multi-agent AI development system using BMad Method"
readme = "README.md"
requires-python = ">=3.10"
license = {{text = "MIT"}}
authors = [
    {{name = "{author}", email = "{email}"}}
]
keywords = ["ai", "agents", "development", "automation"]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]

dependencies = [
    "langgraph>=1.0.5",
    "langchain-core",
    "langchain-anthropic",
    "langchain-openai",
    "chromadb>=1.2.0",
    "typer",
    "rich",
    "pydantic>=2.0.0",
    "pydantic-settings",
    "litellm",
    "tenacity",
    "structlog",
    "pyyaml",
    "python-dotenv",
    "fastmcp>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest",
    "pytest-asyncio",
    "pytest-cov",
    "ruff",
    "mypy",
    "langsmith",
]

[project.scripts]
yolo = "yolo_developer.cli.main:app"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/yolo_developer"]

[tool.ruff]
line-length = 100
target-version = "py310"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "UP"]

[tool.mypy]
python_version = "3.10"
strict = true
warn_return_any = true
warn_unused_configs = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
"""

README_TEMPLATE = """# {name}

Autonomous multi-agent AI development system using BMad Method.

## Installation

```bash
uv sync
```

## Usage

```bash
yolo --help
```

## Development

```bash
uv sync --all-extras
uv run pytest
```
"""


def validate_python_version() -> bool:
    """Validate Python version is >= 3.10."""
    major, minor = sys.version_info[:2]
    if major < 3 or (major == 3 and minor < 10):
        console.print(f"[red]Error: Python 3.10+ required. Found {major}.{minor}[/red]")
        return False
    return True


def create_directory_structure(project_path: Path) -> None:
    """Create the complete directory structure for YOLO Developer per architecture spec."""
    # Source modules per architecture specification
    source_directories = [
        "src/yolo_developer/cli/commands",
        "src/yolo_developer/sdk",
        "src/yolo_developer/mcp",
        "src/yolo_developer/agents/prompts",  # agents with prompts subdirectory
        "src/yolo_developer/orchestrator",
        "src/yolo_developer/memory",
        "src/yolo_developer/gates/gates",  # gates with gates subdirectory for implementations
        "src/yolo_developer/seed",
        "src/yolo_developer/llm",
        "src/yolo_developer/audit",
        "src/yolo_developer/config",
        "src/yolo_developer/utils",
    ]

    # Test directories per architecture specification
    test_directories = [
        "tests/unit/agents",
        "tests/unit/gates",
        "tests/unit/memory",
        "tests/unit/seed",
        "tests/unit/config",
        "tests/integration",
        "tests/e2e",
        "tests/fixtures/seeds",
        "tests/fixtures/states",
    ]

    directories = source_directories + test_directories

    # Collect all Python package directories
    python_package_dirs: set[Path] = set()

    for dir_path in directories:
        full_path = project_path / dir_path
        full_path.mkdir(parents=True, exist_ok=True)

        # Collect all parent directories that should be Python packages
        if dir_path.startswith("src/") or dir_path.startswith("tests/"):
            # Walk from the deepest directory up to src/ or tests/
            current = full_path
            while current != project_path:
                rel_path = current.relative_to(project_path)
                rel_str = str(rel_path)
                # Include tests/ directory itself and all src/yolo_developer/... directories
                if rel_str == "tests" or rel_str.startswith("tests/") or rel_str.startswith("src/"):
                    python_package_dirs.add(current)
                current = current.parent

    # Create __init__.py in all Python package directories
    for pkg_dir in python_package_dirs:
        init_file = pkg_dir / "__init__.py"
        if not init_file.exists():
            init_file.write_text('"""Package."""\n')

    # Create .gitkeep files in empty fixture directories to preserve them in git
    gitkeep_dirs = [
        project_path / "tests" / "fixtures" / "seeds",
        project_path / "tests" / "fixtures" / "states",
    ]
    for gitkeep_dir in gitkeep_dirs:
        gitkeep_file = gitkeep_dir / ".gitkeep"
        if not gitkeep_file.exists():
            gitkeep_file.touch()


def create_pyproject_toml(
    project_path: Path,
    name: str,
    author: str,
    email: str,
) -> Path:
    """Create pyproject.toml from template."""
    content = PYPROJECT_TEMPLATE.format(
        name=name,
        author=author,
        email=email,
    )
    pyproject_path = project_path / "pyproject.toml"
    pyproject_path.write_text(content)
    return pyproject_path


def create_readme(project_path: Path, name: str) -> None:
    """Create README.md."""
    content = README_TEMPLATE.format(name=name)
    readme_path = project_path / "README.md"
    readme_path.write_text(content)


def create_py_typed(project_path: Path) -> None:
    """Create py.typed marker for PEP 561 compliance."""
    py_typed_path = project_path / "src" / "yolo_developer" / "py.typed"
    py_typed_path.touch()


def create_conftest(project_path: Path) -> None:
    """Create pytest conftest.py with initial configuration."""
    conftest_content = '''"""Pytest configuration and shared fixtures."""

from __future__ import annotations

import pytest  # noqa: F401


# Placeholder for shared fixtures
# Add fixtures here as needed during implementation
'''
    conftest_path = project_path / "tests" / "conftest.py"
    if not conftest_path.exists():
        conftest_path.write_text(conftest_content)


def create_mocks_stub(project_path: Path) -> None:
    """Create tests/fixtures/mocks.py stub file for LLM mocking."""
    mocks_content = '''"""Mock objects for testing LLM and external services."""

from __future__ import annotations

from typing import Any  # noqa: F401


class MockLLMResponse:
    """Mock response from LLM calls."""

    def __init__(self, content: str) -> None:
        self.content = content


# Add more mocks as needed during implementation
'''
    mocks_path = project_path / "tests" / "fixtures" / "mocks.py"
    if not mocks_path.exists():
        mocks_path.write_text(mocks_content)


def run_uv_sync(project_path: Path) -> bool:
    """Run uv sync to install dependencies."""
    try:
        subprocess.run(
            ["uv", "sync", "--all-extras", "--python", sys.executable],
            cwd=project_path,
            capture_output=True,
            text=True,
            check=True,
        )
        return True
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Error running uv sync: {e.stderr}[/red]")
        return False
    except FileNotFoundError:
        console.print(
            "[yellow]Warning: uv not found. Run 'uv sync' manually after installation.[/yellow]"
        )
        return True  # Don't fail if uv is not installed


def create_yolo_yaml(project_path: Path, project_name: str, overwrite: bool = False) -> bool:
    """Create yolo.yaml configuration file with sensible defaults.

    Args:
        project_path: Path to the project directory.
        project_name: Name of the project.
        overwrite: If False and yolo.yaml exists, skip creation and return False.

    Returns:
        True if file was created/updated, False if skipped due to existing file.
    """
    yolo_yaml_path = project_path / "yolo.yaml"

    if yolo_yaml_path.exists() and not overwrite:
        console.print(
            "[yellow]yolo.yaml already exists, skipping. "
            "Use a new project or manually update configuration.[/yellow]"
        )
        return False

    content = YOLO_YAML_TEMPLATE.format(
        project_name=project_name,
        llm_cheap_model=LLM_CHEAP_MODEL_DEFAULT,
        llm_premium_model=LLM_PREMIUM_MODEL_DEFAULT,
        llm_best_model=LLM_BEST_MODEL_DEFAULT,
    )
    yolo_yaml_path.write_text(content)
    return True


def _extract_package_name(dep: str) -> str:
    """Extract base package name from a dependency string.

    Handles various formats:
    - package
    - package>=1.0.0
    - package==1.0.0
    - package~=1.0
    - package<2.0
    - package!=1.0
    - package[extra]>=1.0

    Args:
        dep: Dependency string from pyproject.toml.

    Returns:
        Lowercase base package name.
    """
    match = PACKAGE_NAME_PATTERN.match(dep.strip())
    if match:
        return match.group(1).lower()
    # Fallback: return the whole string lowercased if no match
    return dep.strip().lower()


def merge_pyproject_dependencies(project_path: Path) -> None:
    """Merge YOLO dependencies into existing pyproject.toml.

    For brownfield projects, this adds YOLO dependencies without
    overwriting existing configuration. Uses regex-based parsing
    for robust handling of various dependency formats.

    Args:
        project_path: Path to the project directory.
    """
    pyproject_path = project_path / "pyproject.toml"

    try:
        import tomllib
    except ImportError:
        import tomli as tomllib

    # Read existing pyproject.toml
    content = pyproject_path.read_text()
    existing = tomllib.loads(content)

    # YOLO required dependencies
    yolo_deps = [
        "langgraph>=1.0.5",
        "langchain-core",
        "langchain-anthropic",
        "langchain-openai",
        "chromadb>=1.2.0",
        "typer",
        "rich",
        "pydantic>=2.0.0",
        "pydantic-settings",
        "litellm",
        "tenacity",
        "structlog",
        "pyyaml",
        "python-dotenv",
        "fastmcp>=2.0.0",
    ]

    # Get existing dependencies
    existing_deps = existing.get("project", {}).get("dependencies", [])

    # Extract base package names using robust regex parsing
    existing_base_names = {_extract_package_name(d) for d in existing_deps}

    # Filter YOLO deps to only those not already present
    new_deps = [d for d in yolo_deps if _extract_package_name(d) not in existing_base_names]

    if not new_deps:
        console.print("[green]All YOLO dependencies already present.[/green]")
        return

    # Use regex-based approach to find and modify dependencies array
    # This handles various formatting styles more robustly
    deps_pattern = re.compile(
        r"(dependencies\s*=\s*\[)",  # Match "dependencies = [" with flexible whitespace
        re.MULTILINE,
    )

    match = deps_pattern.search(content)
    if match:
        # Insert new deps after the opening bracket
        insert_text = "\n".join(f'    "{d}",' for d in new_deps)
        insert_pos = match.end()
        content = content[:insert_pos] + "\n" + insert_text + content[insert_pos:]
    else:
        # No dependencies section found, add one after [project]
        project_pattern = re.compile(r"(\[project\])", re.MULTILINE)
        project_match = project_pattern.search(content)

        if project_match:
            # Find the next section or end of file
            next_section_pattern = re.compile(r"\n\[(?!project\.)", re.MULTILINE)
            next_match = next_section_pattern.search(content, project_match.end())
            insert_pos = next_match.start() if next_match else len(content)

            deps_text = "\ndependencies = [\n"
            deps_text += "\n".join(f'    "{d}",' for d in yolo_deps)
            deps_text += "\n]\n"
            content = content[:insert_pos] + deps_text + content[insert_pos:]
        else:
            console.print(
                "[yellow]Warning: Could not find [project] section in pyproject.toml. "
                "Please add YOLO dependencies manually.[/yellow]"
            )
            return

    pyproject_path.write_text(content)
    console.print(f"[green]Added {len(new_deps)} YOLO dependencies to pyproject.toml[/green]")


def display_git_status(git_initialized: bool, git_remotes: dict[str, str]) -> None:
    """Display git repository status using Rich table.

    Args:
        git_initialized: Whether the directory is a git repository.
        git_remotes: Dictionary mapping remote names to URLs.
    """
    table = Table(title="Git Repository Status", show_header=True, header_style="bold cyan")
    table.add_column("Property", style="cyan")
    table.add_column("Value")

    status = "[green]Initialized[/green]" if git_initialized else "[yellow]Not initialized[/yellow]"
    table.add_row("Git Status", status)

    if git_initialized:
        if git_remotes:
            remotes_list = ", ".join(
                f"[cyan]{name}[/cyan]" for name in git_remotes.keys()
            )
            table.add_row("Remotes", remotes_list)
        else:
            table.add_row("Remotes", "[dim]None configured[/dim]")

    console.print(table)
    console.print()


def check_gh_cli_available() -> bool:
    """Check if GitHub CLI (gh) is installed and available.

    Returns:
        True if gh CLI is available, False otherwise.
    """
    import shutil

    return shutil.which("gh") is not None


def check_gh_authenticated() -> bool:
    """Check if GitHub CLI is authenticated.

    Returns:
        True if gh is authenticated, False otherwise.
    """
    try:
        result = subprocess.run(
            ["gh", "auth", "status"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.returncode == 0
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def create_github_repo(
    project_path: Path,
    name: str,
    description: str | None = None,
    private: bool = True,
) -> tuple[bool, str | None]:
    """Create a new GitHub repository using gh CLI.

    Args:
        project_path: Path to the project directory.
        name: Repository name.
        description: Optional repository description.
        private: Whether the repository should be private (default True).

    Returns:
        Tuple of (success, repo_url). repo_url is None if creation failed.
    """
    if not check_gh_cli_available():
        logger.warning("gh_cli_not_found", message="GitHub CLI (gh) not installed")
        return False, None

    if not check_gh_authenticated():
        logger.warning("gh_not_authenticated", message="GitHub CLI not authenticated")
        return False, None

    try:
        cmd = ["gh", "repo", "create", name]

        if private:
            cmd.append("--private")
        else:
            cmd.append("--public")

        if description:
            cmd.extend(["--description", description])

        # Add as remote origin and don't clone
        cmd.extend(["--source", str(project_path), "--remote", "origin"])

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=True,
        )

        # Parse the repo URL from output
        repo_url = result.stdout.strip()
        if not repo_url:
            # Try to get it from git remote
            remotes = get_git_remotes(project_path)
            repo_url = remotes.get("origin", "")

        logger.info("github_repo_created", name=name, url=repo_url)
        return True, repo_url

    except subprocess.CalledProcessError as e:
        logger.error("github_repo_creation_failed", error=str(e), stderr=e.stderr)
        return False, None
    except FileNotFoundError:
        logger.warning("gh_cli_not_found", message="GitHub CLI (gh) not installed")
        return False, None


def create_initial_commit(project_path: Path, message: str = "Initial commit") -> bool:
    """Create an initial git commit with all files.

    Args:
        project_path: Path to the project directory.
        message: Commit message.

    Returns:
        True if commit was created successfully, False on error.
    """
    try:
        # Stage all files
        subprocess.run(
            ["git", "add", "."],
            cwd=project_path,
            capture_output=True,
            text=True,
            check=True,
        )

        # Create commit
        subprocess.run(
            ["git", "commit", "-m", message],
            cwd=project_path,
            capture_output=True,
            text=True,
            check=True,
        )

        logger.info("initial_commit_created", project_path=str(project_path))
        return True
    except subprocess.CalledProcessError as e:
        # Empty commit is okay (nothing to commit)
        if "nothing to commit" in e.stdout or "nothing to commit" in (e.stderr or ""):
            logger.debug("no_changes_to_commit", project_path=str(project_path))
            return True
        logger.error("initial_commit_failed", error=str(e), stderr=e.stderr)
        return False
    except FileNotFoundError:
        logger.warning("git_not_found", message="git command not found in PATH")
        return False


def push_to_remote(project_path: Path, remote: str = "origin", branch: str | None = None) -> bool:
    """Push commits to a remote repository.

    Args:
        project_path: Path to the project directory.
        remote: Remote name to push to.
        branch: Branch name to push. If None, uses current branch.

    Returns:
        True if push was successful, False on error.
    """
    try:
        # Get current branch if not specified
        if branch is None:
            result = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                cwd=project_path,
                capture_output=True,
                text=True,
                check=True,
            )
            branch = result.stdout.strip()

        # Push with -u to set upstream
        subprocess.run(
            ["git", "push", "-u", remote, branch],
            cwd=project_path,
            capture_output=True,
            text=True,
            check=True,
        )

        logger.info("pushed_to_remote", remote=remote, branch=branch)
        return True
    except subprocess.CalledProcessError as e:
        logger.error("push_failed", error=str(e), stderr=e.stderr)
        return False
    except FileNotFoundError:
        logger.warning("git_not_found", message="git command not found in PATH")
        return False


def add_git_remote(project_path: Path, name: str, url: str) -> bool:
    """Add a git remote to the repository.

    Args:
        project_path: Path to the project directory.
        name: Remote name (e.g., "origin").
        url: Remote URL.

    Returns:
        True if remote was added successfully, False on error.
    """
    try:
        subprocess.run(
            ["git", "remote", "add", name, url],
            cwd=project_path,
            capture_output=True,
            text=True,
            check=True,
        )
        logger.info("git_remote_added", name=name, url=url)
        return True
    except subprocess.CalledProcessError as e:
        logger.error("git_remote_add_failed", error=str(e), stderr=e.stderr)
        return False
    except FileNotFoundError:
        logger.warning("git_not_found", message="git command not found in PATH")
        return False


def init_git_repository(project_path: Path) -> bool:
    """Initialize a git repository with a .gitignore file.

    Args:
        project_path: Path to the project directory.

    Returns:
        True if git was initialized successfully, False on error.
    """
    try:
        # Initialize git repository
        subprocess.run(
            ["git", "init"],
            cwd=project_path,
            capture_output=True,
            text=True,
            check=True,
        )

        # Create .gitignore if it doesn't exist
        gitignore_path = project_path / ".gitignore"
        if not gitignore_path.exists():
            gitignore_content = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
.env
.venv
env/
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# Testing
.tox/
.coverage
.coverage.*
htmlcov/
.pytest_cache/
.mypy_cache/

# YOLO Developer
.yolo/

# OS
.DS_Store
Thumbs.db
"""
            gitignore_path.write_text(gitignore_content)
            logger.debug("gitignore_created", path=str(gitignore_path))

        logger.info("git_initialized", project_path=str(project_path))
        return True
    except subprocess.CalledProcessError as e:
        logger.error("git_init_failed", error=str(e), stderr=e.stderr)
        return False
    except FileNotFoundError:
        logger.warning("git_not_found", message="git command not found in PATH")
        return False


def init_command(
    path: str | None = None,
    name: str | None = None,
    author: str | None = None,
    email: str | None = None,
    interactive: bool = False,
    no_input: bool = False,
    existing: bool = False,
    scan_only: bool = False,
    non_interactive: bool = False,
    hint: str | None = None,
    skip_git: bool = False,
    skip_github: bool = False,
) -> None:
    """Initialize a new YOLO Developer project.

    Args:
        path: Directory to initialize the project in. Defaults to current directory.
        name: Project name. Defaults to directory name.
        author: Author name for pyproject.toml.
        email: Author email for pyproject.toml.
        interactive: If True, prompt for project details interactively.
        no_input: If True, use all defaults without prompting.
        existing: If True, add YOLO to an existing project (brownfield mode).
        scan_only: If True, scan project without making changes.
        non_interactive: If True, skip all prompts during scanning.
        hint: Optional hint about project type for scanning.
        skip_git: If True, skip git repository initialization prompts.
        skip_github: If True, skip GitHub repository creation prompts.
    """
    import typer

    # Validate Python version
    if not validate_python_version():
        raise SystemExit(1)

    # Resolve project path
    project_path = Path(path) if path else Path.cwd()
    project_path = project_path.resolve()

    # Log git status for debugging and future prompts (Phase 1 - detection only)
    git_initialized = check_git_initialized(project_path)
    git_remotes = get_git_remotes(project_path) if git_initialized else {}
    logger.debug(
        "git_status_detected",
        project_path=str(project_path),
        git_initialized=git_initialized,
        remotes=list(git_remotes.keys()) if git_remotes else [],
    )

    # Prompt for git initialization if not in a git repo (unless skipped)
    if not git_initialized and not skip_git and not no_input:
        if interactive or not existing:
            should_init_git = typer.confirm(
                "This directory is not a git repository. Initialize git?",
                default=True,
            )
            if should_init_git:
                console.print("[blue]Initializing git repository...[/blue]")
                if init_git_repository(project_path):
                    console.print("[green]Git repository initialized![/green]")
                    git_initialized = True
                else:
                    console.print(
                        "[yellow]Warning: Could not initialize git repository.[/yellow]"
                    )

    # Display git status if interactive and git is initialized
    if git_initialized and not no_input and not skip_git:
        # Refresh remotes after potential initialization
        git_remotes = get_git_remotes(project_path)
        display_git_status(git_initialized, git_remotes)

        # Prompt for adding remote if none configured
        if not git_remotes and (interactive or not existing):
            # Check if GitHub CLI is available for repo creation
            gh_available = check_gh_cli_available() and not skip_github

            if gh_available:
                console.print("\n[bold]Remote Repository Options:[/bold]")
                console.print("  1. Create a new GitHub repository")
                console.print("  2. Add an existing remote URL")
                console.print("  3. Skip remote setup")

                choice = typer.prompt(
                    "Choose an option",
                    default="3",
                    show_default=True,
                )

                if choice == "1":
                    # Create GitHub repository
                    repo_name = typer.prompt(
                        "Repository name",
                        default=project_path.name,
                    )
                    repo_desc = typer.prompt(
                        "Repository description (optional)",
                        default="",
                    )
                    is_private = typer.confirm(
                        "Make repository private?",
                        default=True,
                    )

                    console.print("[blue]Creating GitHub repository...[/blue]")
                    success, repo_url = create_github_repo(
                        project_path,
                        repo_name,
                        description=repo_desc if repo_desc else None,
                        private=is_private,
                    )

                    if success:
                        console.print(
                            f"[green]GitHub repository created: {repo_url}[/green]"
                        )
                        git_remotes = get_git_remotes(project_path)
                    else:
                        if not check_gh_authenticated():
                            console.print(
                                "[yellow]GitHub CLI not authenticated. "
                                "Run 'gh auth login' first.[/yellow]"
                            )
                        else:
                            console.print(
                                "[yellow]Could not create GitHub repository.[/yellow]"
                            )

                elif choice == "2":
                    remote_url = typer.prompt(
                        "Enter remote URL (e.g., https://github.com/user/repo.git)"
                    )
                    if remote_url.strip():
                        if add_git_remote(project_path, "origin", remote_url.strip()):
                            console.print(
                                f"[green]Remote 'origin' added: {remote_url}[/green]"
                            )
                            git_remotes = {"origin": remote_url.strip()}
                        else:
                            console.print(
                                "[yellow]Warning: Could not add remote.[/yellow]"
                            )
            else:
                # GitHub CLI not available, just offer manual remote addition
                should_add_remote = typer.confirm(
                    "No remote repository configured. Would you like to add one?",
                    default=False,
                )
                if should_add_remote:
                    remote_url = typer.prompt(
                        "Enter remote URL (e.g., https://github.com/user/repo.git)"
                    )
                    if remote_url.strip():
                        if add_git_remote(project_path, "origin", remote_url.strip()):
                            console.print(
                                f"[green]Remote 'origin' added: {remote_url}[/green]"
                            )
                            git_remotes = {"origin": remote_url.strip()}
                        else:
                            console.print(
                                "[yellow]Warning: Could not add remote.[/yellow]"
                            )

    # Create directory if it doesn't exist (greenfield only)
    if not existing:
        project_path.mkdir(parents=True, exist_ok=True)

    # Get defaults from git config
    git_user_name = get_git_config("user.name")
    git_user_email = get_git_config("user.email")

    if non_interactive:
        interactive = False
        no_input = True

    # Determine project name
    default_name = project_path.name
    if name:
        project_name = name
    elif interactive and not no_input:
        project_name = typer.prompt("Project name", default=default_name)
    else:
        project_name = default_name

    # Determine author info
    default_author = git_user_name or "Developer"
    if author:
        author_name = author
    elif interactive and not no_input:
        author_name = typer.prompt("Author name", default=default_author)
    else:
        author_name = git_user_name or "YOLO Developer"

    default_email = git_user_email or "dev@example.com"
    if email:
        author_email = email
    elif interactive and not no_input:
        author_email = typer.prompt("Author email", default=default_email)
    else:
        author_email = git_user_email or "dev@example.com"

    console.print(
        Panel(
            f"Initializing YOLO Developer project: [bold]{project_name}[/bold]"
            + (" (brownfield mode)" if existing else ""),
            title="YOLO Init",
            border_style="blue",
        )
    )

    if existing:
        # Brownfield mode: scan and add YOLO to existing project
        brownfield_config = BrownfieldConfig()
        _run_brownfield_scan(
            project_path=project_path,
            project_name=project_name,
            interactive=interactive,
            scan_only=scan_only,
            hint=hint,
            config=brownfield_config,
        )
        if scan_only:
            return

        pyproject_path = project_path / "pyproject.toml"
        if pyproject_path.exists():
            console.print("[blue]Adding YOLO dependencies to existing project...[/blue]")
            merge_pyproject_dependencies(project_path)
        else:
            console.print(
                "[yellow]No pyproject.toml found. Skipping dependency merge.[/yellow]"
            )

        # Create yolo.yaml (skip if already exists in brownfield mode)
        console.print("[blue]Checking yolo.yaml configuration...[/blue]")
        create_yolo_yaml(project_path, project_name, overwrite=False)

    else:
        # Greenfield mode: create new project
        # Create directory structure
        console.print("[blue]Creating directory structure...[/blue]")
        create_directory_structure(project_path)

        # Create pyproject.toml
        console.print("[blue]Creating pyproject.toml...[/blue]")
        create_pyproject_toml(project_path, project_name, author_name, author_email)

        # Create README
        console.print("[blue]Creating README.md...[/blue]")
        create_readme(project_path, project_name)

        # Create py.typed marker
        console.print("[blue]Creating py.typed marker...[/blue]")
        create_py_typed(project_path)

        # Create pytest conftest.py
        console.print("[blue]Creating pytest configuration...[/blue]")
        create_conftest(project_path)

        # Create mocks stub
        console.print("[blue]Creating test fixtures...[/blue]")
        create_mocks_stub(project_path)

        # Create yolo.yaml (overwrite allowed in greenfield mode)
        console.print("[blue]Creating yolo.yaml configuration...[/blue]")
        create_yolo_yaml(project_path, project_name, overwrite=True)

    # Run uv sync
    console.print("[blue]Installing dependencies with uv...[/blue]")
    if run_uv_sync(project_path):
        console.print("[green]Dependencies installed successfully![/green]")
    else:
        console.print("[yellow]Please run 'uv sync' manually.[/yellow]")

    # Offer to create initial commit if git is initialized
    if git_initialized and not no_input and not skip_git:
        should_commit = typer.confirm(
            "Create initial commit with project files?",
            default=True,
        )
        if should_commit:
            console.print("[blue]Creating initial commit...[/blue]")
            if create_initial_commit(project_path, "Initial YOLO Developer project setup"):
                console.print("[green]Initial commit created![/green]")

                # Offer to push if remote is configured
                git_remotes = get_git_remotes(project_path)
                if git_remotes and not skip_github:
                    should_push = typer.confirm(
                        "Push initial commit to remote?",
                        default=True,
                    )
                    if should_push:
                        console.print("[blue]Pushing to remote...[/blue]")
                        if push_to_remote(project_path):
                            console.print("[green]Pushed to remote successfully![/green]")
                        else:
                            console.print(
                                "[yellow]Could not push to remote. "
                                "You can push manually later.[/yellow]"
                            )
            else:
                console.print(
                    "[yellow]Could not create initial commit.[/yellow]"
                )

    console.print(
        Panel(
            f"[green]Project initialized successfully at:[/green]\n{project_path}\n\n"
            f"[blue]Next steps:[/blue]\n"
            f"  cd {project_path}\n"
            f"  yolo --help",
            title="Success",
            border_style="green",
        )
    )


def _run_brownfield_scan(
    project_path: Path,
    project_name: str,
    interactive: bool,
    scan_only: bool,
    hint: str | None,
    config: BrownfieldConfig,
) -> "ProjectContext | None":
    console.print("[blue]Scanning existing project...[/blue]")
    manager = ScannerManager()
    report = manager.scan(
        project_path=project_path,
        scan_depth=config.scan_depth,
        exclude_patterns=config.exclude_patterns,
        max_files=config.max_files_to_analyze,
        include_git_history=config.include_git_history,
        hint=hint,
    )
    _print_scan_report(report)

    if scan_only:
        console.print("[green]Scan complete (no changes made).[/green]")
        return None

    context = manager.build_project_context(
        report=report,
        project_name=project_name,
        interactive=interactive and config.interactive,
        console=console,
    )
    output_path = manager.write_project_context(project_path, context)
    console.print(f"[green]Generated project context:[/green] {output_path}")
    return context


def _print_scan_report(report) -> None:
    table = Table(title="Brownfield Scan Summary")
    table.add_column("Finding")
    table.add_column("Value")
    table.add_column("Confidence", justify="right")

    for finding in report.findings:
        if finding.key in {"docs", "git", "conventions"}:
            continue
        table.add_row(finding.key, str(finding.value), f"{finding.confidence:.0%}")

    console.print(table)

    if report.suggestions:
        console.print("[yellow]Suggestions:[/yellow]")
        for suggestion in report.suggestions:
            console.print(f"  - {suggestion}")
