# Story 8.7: Pattern Following

Status: done

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a developer,
I want generated code to follow existing patterns,
So that the codebase remains consistent.

## Acceptance Criteria

1. **AC1: Follow Established Naming Conventions**
   - **Given** existing codebase patterns from memory store
   - **When** new code is generated by dev_node
   - **Then** `analyze_naming_patterns()` queries PatternLearner for naming patterns
   - **And** generated code uses consistent function naming (snake_case per patterns)
   - **And** generated code uses consistent class naming (PascalCase per patterns)
   - **And** generated code uses consistent variable naming (snake_case per patterns)
   - **And** naming patterns are logged for audit trail

2. **AC2: Use Consistent Error Handling Patterns**
   - **Given** error handling patterns detected in existing codebase
   - **When** code with error handling is generated
   - **Then** `analyze_error_handling_patterns()` extracts patterns from existing code
   - **And** generated code uses same error handling approach (try/except structure)
   - **And** generated code follows existing exception class hierarchies
   - **And** generated code uses existing custom exception classes when appropriate
   - **And** error handling pattern adherence is included in validation result

3. **AC3: Match Existing Code Style**
   - **Given** code style patterns from memory store (imports, docstrings, type hints)
   - **When** code is generated
   - **Then** `analyze_style_patterns()` extracts import style (absolute vs relative)
   - **And** generated code uses consistent import ordering (stdlib, third-party, local)
   - **And** generated code uses same docstring format (Google-style per architecture)
   - **And** generated code uses consistent type annotation style
   - **And** style adherence is included in pattern validation result

4. **AC4: Flag and Justify Deviations**
   - **Given** generated code that deviates from established patterns
   - **When** pattern validation runs via `validate_pattern_adherence()`
   - **Then** all deviations are flagged with specific pattern violation details
   - **And** each deviation includes severity (high=requires justification, medium=warning, low=info)
   - **And** deviations requiring justification are logged with rationale
   - **And** `PatternValidationResult` includes list of deviations and overall score

5. **AC5: Pattern Integration with Dev Node**
   - **Given** dev_node generates implementation artifacts
   - **When** LLM-powered code generation runs
   - **Then** `_get_relevant_patterns()` queries PatternLearner from memory_context in state
   - **And** patterns are included in the code generation prompt
   - **And** generated code is validated for pattern adherence post-generation
   - **And** pattern validation results are included in DevOutput and decision record

6. **AC6: Pattern Query API**
   - **Given** the need to programmatically query patterns for validation
   - **When** pattern APIs are called
   - **Then** `get_naming_patterns(state: YoloState) -> list[CodePattern]` returns naming patterns
   - **And** `get_error_patterns(state: YoloState) -> list[ErrorHandlingPattern]` returns error patterns
   - **And** `get_style_patterns(state: YoloState) -> list[StylePattern]` returns style patterns
   - **And** all pattern queries use PatternLearner from state or fallback to defaults

7. **AC7: Exports from Dev Module**
   - **Given** new pattern following utilities
   - **When** importing from `yolo_developer.agents.dev`
   - **Then** `PatternValidationResult` is exported
   - **And** `PatternDeviation` is exported
   - **And** `validate_pattern_adherence` is exported
   - **And** `get_naming_patterns`, `get_error_patterns`, `get_style_patterns` are exported

## Tasks / Subtasks

- [x] Task 1: Create Pattern Following Types (AC: 4, 6, 7)
  - [x] Create `src/yolo_developer/agents/dev/pattern_utils.py`
  - [x] Create `PatternDeviation` dataclass with fields: pattern_type, pattern_name, expected_value, actual_value, severity, justification
  - [x] Create `PatternValidationResult` dataclass with fields: passed, score, deviations, patterns_checked, adherence_percentage
  - [x] Create `ErrorHandlingPattern` dataclass with fields: pattern_name, exception_types, handling_style, examples
  - [x] Create `StylePattern` dataclass with fields: pattern_name, category (import/docstring/type_hint), value, examples
  - [x] Add type annotations for all new types

- [x] Task 2: Implement Pattern Query Functions (AC: 6)
  - [x] Create `get_naming_patterns(state: YoloState) -> list[CodePattern]`
  - [x] Create `get_error_patterns(state: YoloState) -> list[ErrorHandlingPattern]`
  - [x] Create `get_style_patterns(state: YoloState) -> list[StylePattern]`
  - [x] Import and use PatternLearner from memory module
  - [x] Handle case where memory_context is not in state (return defaults)
  - [x] Cache patterns during single dev_node invocation for efficiency (via functools.lru_cache)

- [x] Task 3: Implement Naming Pattern Analysis (AC: 1)
  - [x] Create `analyze_naming_patterns(code: str, patterns: list[CodePattern]) -> list[PatternDeviation]`
  - [x] Extract function names using AST and check against naming patterns
  - [x] Extract class names using AST and check against naming patterns
  - [x] Extract variable names using AST and check against naming patterns
  - [x] Return list of deviations with severity based on pattern confidence

- [x] Task 4: Implement Error Handling Pattern Analysis (AC: 2)
  - [x] Create `analyze_error_handling_patterns(code: str, patterns: list[ErrorHandlingPattern]) -> list[PatternDeviation]`
  - [x] Extract try/except blocks using AST
  - [x] Check exception types used match existing patterns
  - [x] Check exception handling style (specific vs generic exceptions)
  - [x] Return deviations for inconsistent error handling

- [x] Task 5: Implement Style Pattern Analysis (AC: 3)
  - [x] Create `analyze_style_patterns(code: str, patterns: list[StylePattern]) -> list[PatternDeviation]`
  - [x] Check import statement ordering (stdlib, third-party, local)
  - [x] Check docstring presence and format
  - [x] Check type annotation consistency
  - [x] Return deviations for style inconsistencies

- [x] Task 6: Implement Pattern Validation Aggregation (AC: 4, 5)
  - [x] Create `validate_pattern_adherence(code: str, state: YoloState) -> PatternValidationResult`
  - [x] Call all analysis functions (naming, error handling, style)
  - [x] Aggregate deviations into PatternValidationResult
  - [x] Calculate adherence percentage (patterns matched / patterns checked)
  - [x] Calculate score using deviation severity weights
  - [x] Log validation results for audit trail via structlog

- [x] Task 7: Integrate Pattern Following into Dev Node (AC: 5)
  - [x] Update `_extract_project_context()` in node.py to include pattern queries
  - [x] Create `_get_relevant_patterns(state: YoloState) -> dict[str, list]` helper
  - [x] Update `build_code_generation_prompt()` to include patterns in prompt
  - [x] Call `validate_pattern_adherence()` after code generation
  - [x] Include pattern validation result in DevOutput processing_notes
  - [x] Include pattern adherence in decision record rationale

- [x] Task 8: Update Prompt Templates for Pattern Context (AC: 1, 2, 3)
  - [x] Integrate patterns into prompt via `additional_context` parameter (patterns formatted by `_format_patterns_for_prompt()` in node.py)
  - [x] Add naming pattern instructions to prompt
  - [x] Add error handling pattern instructions to prompt
  - [x] Add style pattern instructions to prompt
  - [x] Format patterns for LLM consumption (examples, conventions)

- [x] Task 9: Export Functions from Dev Module (AC: 7)
  - [x] Update `src/yolo_developer/agents/dev/__init__.py`
  - [x] Export `PatternValidationResult`
  - [x] Export `PatternDeviation`
  - [x] Export `ErrorHandlingPattern`
  - [x] Export `StylePattern`
  - [x] Export `validate_pattern_adherence`
  - [x] Export `get_naming_patterns`, `get_error_patterns`, `get_style_patterns`
  - [x] Export `analyze_naming_patterns`, `analyze_error_handling_patterns`, `analyze_style_patterns`

- [x] Task 10: Write Unit Tests for Pattern Types (AC: 4, 6, 7)
  - [x] Create `tests/unit/agents/dev/test_pattern_utils.py`
  - [x] Test `PatternDeviation` dataclass construction
  - [x] Test `PatternValidationResult` dataclass construction and score calculation
  - [x] Test `ErrorHandlingPattern` and `StylePattern` dataclass construction
  - [x] Test `to_dict()` serialization methods

- [x] Task 11: Write Unit Tests for Pattern Query Functions (AC: 6)
  - [x] Test `get_naming_patterns()` with memory_context in state
  - [x] Test `get_naming_patterns()` without memory_context (default patterns)
  - [x] Test `get_error_patterns()` with memory_context
  - [x] Test `get_style_patterns()` with memory_context
  - [x] Mock PatternLearner for isolated testing

- [x] Task 12: Write Unit Tests for Naming Analysis (AC: 1)
  - [x] Test `analyze_naming_patterns()` with snake_case functions
  - [x] Test `analyze_naming_patterns()` with PascalCase classes
  - [x] Test `analyze_naming_patterns()` detecting camelCase deviation
  - [x] Test `analyze_naming_patterns()` with no patterns (empty list)

- [x] Task 13: Write Unit Tests for Error Handling Analysis (AC: 2)
  - [x] Test `analyze_error_handling_patterns()` with matching patterns
  - [x] Test `analyze_error_handling_patterns()` with generic Exception usage
  - [x] Test `analyze_error_handling_patterns()` detecting bare except
  - [x] Test `analyze_error_handling_patterns()` with custom exceptions

- [x] Task 14: Write Unit Tests for Style Analysis (AC: 3)
  - [x] Test `analyze_style_patterns()` import ordering
  - [x] Test `analyze_style_patterns()` docstring format
  - [x] Test `analyze_style_patterns()` type annotation presence
  - [x] Test `analyze_style_patterns()` with multiple style deviations

- [x] Task 15: Write Unit Tests for Pattern Validation (AC: 4, 5)
  - [x] Test `validate_pattern_adherence()` with fully compliant code
  - [x] Test `validate_pattern_adherence()` with multiple deviations
  - [x] Test `validate_pattern_adherence()` score calculation
  - [x] Test `validate_pattern_adherence()` severity aggregation

- [x] Task 16: Write Integration Tests for Dev Node Pattern Following (AC: 5)
  - [x] Create `tests/unit/agents/dev/test_pattern_utils.py` (unit tests cover integration)
  - [x] Test dev_node extracts patterns from state
  - [x] Test dev_node includes patterns in prompt context
  - [x] Test dev_node validates generated code for pattern adherence
  - [x] Test dev_node decision record includes pattern validation summary

## Dev Notes

### Architecture Compliance

- **ADR-001 (State Management):** Use TypedDict for pattern query from state, frozen dataclasses for pattern types
- **ADR-005 (LangGraph Communication):** Access patterns via state["memory_context"], never direct memory store calls
- **ADR-006 (Quality Gates):** Pattern validation is advisory (like DoD), not blocking
- **ADR-007 (Error Handling):** Handle missing memory_context gracefully with default patterns
- **ARCH-QUALITY-6:** Use structlog for all logging with structured fields
- **ARCH-QUALITY-7:** Full type annotations on all functions
- **FR62:** Dev Agent can follow existing codebase patterns and conventions

### Technical Requirements

- Use `from __future__ import annotations` in all new files
- Use snake_case for all function names and variables
- Follow existing patterns from `agents/dev/node.py` (Stories 8.1-8.6)
- Use frozen dataclasses for immutable pattern types
- REUSE existing `CodePattern` from `memory/patterns.py`
- REUSE existing `PatternLearner` from `memory/learning.py`
- Use AST parsing for code analysis (not regex)

### Library Versions (from architecture.md)

| Library | Version | Purpose |
|---------|---------|---------|
| LangGraph | 1.0.5 | Orchestration framework |
| structlog | latest | Structured logging |
| tenacity | latest | Retry with backoff |
| pytest | latest | Test framework |
| pytest-asyncio | latest | Async test support |

### Project Structure Notes

**New Files to Create:**
- `src/yolo_developer/agents/dev/pattern_utils.py` - Pattern following utilities

**Files to Modify:**
- `src/yolo_developer/agents/dev/__init__.py` - Export new functions and types
- `src/yolo_developer/agents/dev/node.py` - Integrate pattern following into dev_node
- `src/yolo_developer/agents/dev/prompts/code_generation.py` - Add pattern context to prompts

**Test Files:**
- `tests/unit/agents/dev/test_pattern_utils.py`
- `tests/integration/agents/dev/test_pattern_following.py`

### Key Type Definitions

```python
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Literal

from yolo_developer.memory.patterns import CodePattern, PatternType


@dataclass(frozen=True)
class PatternDeviation:
    """A detected deviation from an established pattern.

    Attributes:
        pattern_type: Type of pattern deviated from.
        pattern_name: Human-readable pattern identifier.
        expected_value: What the pattern specifies.
        actual_value: What was found in the code.
        severity: Deviation severity (high=requires justification, medium=warning, low=info).
        justification: Optional justification for the deviation.
        location: Optional code location (line number or function name).
    """
    pattern_type: PatternType
    pattern_name: str
    expected_value: str
    actual_value: str
    severity: Literal["high", "medium", "low"]
    justification: str | None = None
    location: str | None = None


@dataclass(frozen=True)
class ErrorHandlingPattern:
    """Pattern describing error handling conventions.

    Attributes:
        pattern_name: Human-readable identifier.
        exception_types: Tuple of exception types commonly caught.
        handling_style: Description of handling approach (e.g., "specific exceptions", "reraise with context").
        examples: Code examples demonstrating the pattern.
    """
    pattern_name: str
    exception_types: tuple[str, ...]
    handling_style: str
    examples: tuple[str, ...] = field(default_factory=tuple)


@dataclass(frozen=True)
class StylePattern:
    """Pattern describing code style conventions.

    Attributes:
        pattern_name: Human-readable identifier.
        category: Style category (import_style, docstring_format, type_hint_style).
        value: The detected style value.
        examples: Code examples demonstrating the pattern.
    """
    pattern_name: str
    category: Literal["import_style", "docstring_format", "type_hint_style"]
    value: str
    examples: tuple[str, ...] = field(default_factory=tuple)


@dataclass
class PatternValidationResult:
    """Result of pattern adherence validation.

    Note: Not frozen because deviations are appended during validation.

    Attributes:
        score: Adherence score 0-100.
        passed: Whether score meets threshold (default 70).
        threshold: Score threshold for pass/fail.
        patterns_checked: Number of patterns validated against.
        adherence_percentage: Percentage of patterns followed correctly.
        deviations: List of detected pattern deviations.
    """
    score: int = 100
    passed: bool = True
    threshold: int = 70
    patterns_checked: int = 0
    adherence_percentage: float = 100.0
    deviations: list[PatternDeviation] = field(default_factory=list)

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "score": self.score,
            "passed": self.passed,
            "threshold": self.threshold,
            "patterns_checked": self.patterns_checked,
            "adherence_percentage": self.adherence_percentage,
            "deviation_count": len(self.deviations),
            "deviations": [
                {
                    "pattern_type": d.pattern_type.value,
                    "pattern_name": d.pattern_name,
                    "expected": d.expected_value,
                    "actual": d.actual_value,
                    "severity": d.severity,
                }
                for d in self.deviations
            ],
        }
```

### Key Function Signatures

```python
def validate_pattern_adherence(
    code: str,
    state: YoloState,
    threshold: int = 70,
) -> PatternValidationResult:
    """Validate code adherence to established patterns.

    Analyzes code for naming, error handling, and style pattern compliance.
    Queries patterns from state["memory_context"] via PatternLearner.

    Args:
        code: Python source code to validate.
        state: YoloState containing memory_context with patterns.
        threshold: Minimum score to pass (0-100, default 70).

    Returns:
        PatternValidationResult with score, pass/fail, and deviations.

    Example:
        >>> result = validate_pattern_adherence(code, state)
        >>> result.passed
        True
        >>> result.adherence_percentage
        95.5
    """


def get_naming_patterns(state: YoloState) -> list[CodePattern]:
    """Get naming patterns from state or return defaults.

    Queries PatternLearner for NAMING_FUNCTION, NAMING_CLASS, NAMING_VARIABLE patterns.

    Args:
        state: YoloState containing memory_context.

    Returns:
        List of CodePattern for naming conventions.
    """


def analyze_naming_patterns(
    code: str,
    patterns: list[CodePattern],
) -> list[PatternDeviation]:
    """Analyze code for naming pattern deviations.

    Uses AST to extract function, class, and variable names.
    Compares against established naming patterns.

    Args:
        code: Python source code to analyze.
        patterns: Naming patterns to check against.

    Returns:
        List of PatternDeviation for naming violations.
    """
```

### Integration with Memory System

The pattern following feature integrates with the existing memory system from Epic 2:

```python
# Accessing patterns from state (recommended approach)
def _get_relevant_patterns(state: YoloState) -> dict[str, list]:
    """Get patterns from memory_context in state."""
    memory_context = state.get("memory_context")

    if memory_context is None:
        # Return default patterns (project architecture conventions)
        return _get_default_patterns()

    # Access PatternLearner from memory context
    learner = memory_context.get("pattern_learner")
    if learner is None:
        return _get_default_patterns()

    # Query patterns by type
    naming_patterns = await learner.get_patterns_by_type(PatternType.NAMING_FUNCTION)
    # ... etc
```

### Default Patterns (from Architecture)

When memory_context is not available, use architecture-defined patterns:

```python
DEFAULT_NAMING_PATTERNS = [
    CodePattern(
        pattern_type=PatternType.NAMING_FUNCTION,
        name="function_naming",
        value="snake_case",
        confidence=1.0,
        examples=("get_user", "validate_input", "process_order"),
    ),
    CodePattern(
        pattern_type=PatternType.NAMING_CLASS,
        name="class_naming",
        value="PascalCase",
        confidence=1.0,
        examples=("UserService", "OrderProcessor", "DataValidator"),
    ),
]

DEFAULT_STYLE_PATTERNS = [
    StylePattern(
        pattern_name="import_ordering",
        category="import_style",
        value="stdlib, third_party, local (separated by blank lines)",
        examples=("from __future__ import annotations\n\nimport asyncio\n\nfrom pydantic import BaseModel",),
    ),
    StylePattern(
        pattern_name="docstring_format",
        category="docstring_format",
        value="Google-style",
        examples=('"""Summary line.\n\nArgs:\n    param: Description.\n\nReturns:\n    Description.\n"""',),
    ),
]
```

### Previous Story Learnings Applied (Stories 8.1-8.6)

From Story 8.1 (Create Dev Agent Node):
- dev_node integrates with state via `_extract_project_context()`
- Patterns are already partially extracted in context["patterns"]
- Need to expand to include full pattern validation

From Story 8.2 (Maintainable Code Generation):
- Prompt includes conventions from context
- Need to enhance with specific pattern examples

From Story 8.6 (DoD Validation):
- `DoDValidationResult` pattern for validation results
- `to_dict()` method for serialization
- Score-based pass/fail with threshold
- Non-frozen dataclass for incremental building

From existing Memory system (Epic 2):
- PatternLearner provides `get_patterns_by_type()` and `search_patterns()`
- CodePattern has `to_embedding_text()` for prompts
- Pattern confidence scores guide prioritization

### AST-Based Code Analysis Pattern

Use Python's AST module for reliable code analysis:

```python
import ast

def _extract_names_from_code(code: str) -> dict[str, list[str]]:
    """Extract function, class, and variable names using AST."""
    try:
        tree = ast.parse(code)
    except SyntaxError:
        return {"functions": [], "classes": [], "variables": []}

    names = {
        "functions": [],
        "classes": [],
        "variables": [],
    }

    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            names["functions"].append(node.name)
        elif isinstance(node, ast.ClassDef):
            names["classes"].append(node.name)
        elif isinstance(node, ast.Name) and isinstance(node.ctx, ast.Store):
            names["variables"].append(node.id)

    return names
```

### Git Commit Pattern

Recent commits follow pattern:
```
feat: Implement <feature> with code review fixes (Story X.Y)
```

### Story Dependencies

This story builds on:
- Story 2.6 (Project Pattern Learning) - PatternLearner and pattern types
- Story 8.1 (Create Dev Agent Node) - dev_node and _extract_project_context()
- Story 8.2 (Maintainable Code Generation) - LLM code generation with prompts
- Stories 8.3-8.6 - dev module patterns and utilities

This story enables:
- Story 8.8 (Communicative Commits) - can reference pattern adherence in commit messages
- Story 9.x (TEA Agent) - TEA can validate pattern following

### Functional Requirements Addressed

| FR | Description | How Addressed |
|----|-------------|---------------|
| FR62 | Dev Agent can follow existing codebase patterns and conventions | Pattern query, analysis, validation, and prompt integration |

### Severity Weights for Scoring

```python
# Pattern deviation severity weights (similar to DoD)
DEVIATION_SEVERITY_WEIGHTS = {
    "high": 20,    # Major pattern violation (wrong naming convention)
    "medium": 10,  # Moderate deviation (inconsistent style)
    "low": 3,      # Minor variation (slightly different formatting)
}

# Calculate score: start at 100, subtract weighted deviations
def _calculate_pattern_score(deviations: list[PatternDeviation]) -> int:
    score = 100
    for deviation in deviations:
        score -= DEVIATION_SEVERITY_WEIGHTS[deviation.severity]
    return max(0, score)
```

### References

- [Source: _bmad-output/planning-artifacts/epics.md#Epic-8] - Epic definition
- [Source: _bmad-output/planning-artifacts/epics.md#Story-8.7] - Story definition
- [Source: _bmad-output/planning-artifacts/architecture.md#Implementation-Patterns] - Naming and style patterns
- [Source: src/yolo_developer/memory/patterns.py] - CodePattern and PatternType types
- [Source: src/yolo_developer/memory/learning.py] - PatternLearner class
- [Source: src/yolo_developer/agents/dev/node.py] - Existing dev_node implementation
- [Source: src/yolo_developer/agents/dev/dod_utils.py] - DoDValidationResult pattern reference
- [Source: _bmad-output/implementation-artifacts/8-6-dod-validation.md] - Previous story learnings
- [FR62: Dev Agent can follow existing codebase patterns and conventions]

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

- All tests passing: 50 tests (39 unit + 11 integration), 462 total in tests/unit/agents/dev/
- Type checking passing: mypy clean on all dev agent files
- Linting passing: ruff clean on all files

### Completion Notes List

- Implemented comprehensive pattern following with AST-based analysis
- Pattern validation is advisory (like DoD), not blocking
- Default patterns based on architecture document conventions
- Integrated with existing memory system via PatternLearner queries
- Patterns included in LLM code generation prompts
- Pattern adherence results in artifact notes and audit logs
- Added pattern caching for efficiency during single dev_node invocation
- Fixed adherence_percentage calculation to properly reflect patterns without deviations

### Code Review Fixes (2026-01-11)

Issues identified and fixed during adversarial code review:
1. **Issue #1 (MEDIUM):** Created missing integration test file `tests/integration/agents/dev/test_pattern_following.py` (11 tests)
2. **Issue #2 (MEDIUM):** Updated Task 8 description to accurately reflect implementation approach (patterns via additional_context)
3. **Issue #3 (LOW):** Added module-level pattern caching with `clear_pattern_cache()` function
4. **Issue #4 (LOW):** Removed unused imports (AsyncMock, patch) from test files
5. **Issue #5 (LOW):** Simplified `_check_docstring_format()` to remove dead code, added clarifying comments
6. **Issue #6 (LOW):** Fixed `adherence_percentage` calculation to properly compute patterns without deviations

### File List

**New Files:**
- `src/yolo_developer/agents/dev/pattern_utils.py` - Pattern following utilities (1000+ lines)
- `tests/unit/agents/dev/test_pattern_utils.py` - Unit tests (39 tests)
- `tests/integration/agents/dev/test_pattern_following.py` - Integration tests (11 tests)

**Modified Files:**
- `src/yolo_developer/agents/dev/node.py` - Added pattern integration to dev_node
- `src/yolo_developer/agents/dev/__init__.py` - Exported new types and functions (12 exports)
