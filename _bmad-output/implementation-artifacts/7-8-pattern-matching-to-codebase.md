# Story 7.8: Pattern Matching to Codebase

Status: done

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a developer,
I want designs match existing codebase patterns,
so that generated code is consistent with what I already have.

## Acceptance Criteria

1. **Given** an existing codebase with learned patterns (from Epic 2 Memory Layer)
   **When** new designs are generated by the Architect agent
   **Then** they follow established patterns from the codebase
   **And** results are returned as a `PatternMatchingResult` frozen dataclass
   **And** the function is importable from `yolo_developer.agents.architect`

2. **Given** design decisions from the Architect
   **When** pattern matching validates naming conventions
   **Then** naming conventions from the codebase are maintained
   **And** violations are flagged with the expected pattern and actual usage
   **And** confidence score indicates pattern consistency (0.0-1.0)

3. **Given** existing architectural style in the codebase
   **When** pattern matching analyzes new design decisions
   **Then** architectural style consistency is checked
   **And** inconsistencies are documented with justification requirements
   **And** pattern types checked include: naming, structure, imports, design patterns

4. **Given** pattern deviations are detected
   **When** the pattern matching completes
   **Then** deviations are justified and documented
   **And** each deviation includes: pattern_type, expected, actual, justification, severity
   **And** high-severity unjustified deviations fail the pattern check

5. **Given** the architect_node processing stories
   **When** pattern matching is performed
   **Then** it runs after ATAM review (Story 7.7)
   **And** it uses patterns from the memory layer (Epic 2: PatternLearner, ChromaPatternStore)
   **And** results are included in ArchitectOutput
   **And** summary is logged via structlog

6. **Given** LLM-powered pattern analysis
   **When** analyzing complex pattern scenarios
   **Then** it uses litellm with configurable model via env var
   **And** it includes tenacity retry with exponential backoff
   **And** it handles LLM failures gracefully with rule-based fallback

7. **Given** the PatternMatchingResult dataclass
   **When** all analysis is complete
   **Then** it is frozen (immutable) per ADR-001
   **And** it has to_dict() method for serialization
   **And** it includes overall_pass (True/False) based on pattern conformance thresholds

## Tasks / Subtasks

- [x] Task 1: Create Pattern Matching Type Definitions (AC: 1, 7)
  - [x] Create `PatternViolation` frozen dataclass with: pattern_type, expected, actual, file_context, severity, justification
  - [x] Create `PatternDeviation` frozen dataclass with: pattern_type, standard_pattern, proposed_pattern, justification, is_justified, severity
  - [x] Create `PatternMatchingResult` frozen dataclass with: overall_pass, confidence, patterns_checked, violations, deviations, recommendations, summary, to_dict()
  - [x] Add PatternCheckSeverity literal type: "critical", "high", "medium", "low"
  - [x] Add type exports to `architect/__init__.py`

- [x] Task 2: Implement Pattern Retrieval from Memory (AC: 1, 2, 3)
  - [x] Create `src/yolo_developer/agents/architect/pattern_matcher.py` module
  - [x] Implement `_get_learned_patterns(pattern_store: ChromaPatternStore | None) -> list[CodePattern]`
  - [x] Query patterns by type: NAMING_FUNCTION, NAMING_CLASS, NAMING_VARIABLE, NAMING_MODULE
  - [x] Query patterns by type: STRUCTURE_DIRECTORY, STRUCTURE_FILE, IMPORT_STYLE, DESIGN_PATTERN
  - [x] Handle case where pattern store is not available (return empty list)
  - [x] Add structlog logging for pattern retrieval

- [x] Task 3: Implement Naming Convention Checking (AC: 2)
  - [x] Implement `_check_naming_conventions(decisions: list[DesignDecision], patterns: list[CodePattern]) -> list[PatternViolation]`
  - [x] Check function naming patterns against NAMING_FUNCTION patterns
  - [x] Check class naming patterns against NAMING_CLASS patterns
  - [x] Check module naming patterns against NAMING_MODULE patterns
  - [x] Calculate confidence score based on pattern matches
  - [x] Flag violations with expected vs actual naming

- [x] Task 4: Implement Architectural Style Checking (AC: 3)
  - [x] Implement `_check_architectural_style(decisions: list[DesignDecision], patterns: list[CodePattern]) -> list[PatternViolation]`
  - [x] Check structure patterns against STRUCTURE_DIRECTORY patterns
  - [x] Check import style against IMPORT_STYLE patterns
  - [x] Check design patterns against DESIGN_PATTERN patterns
  - [x] Identify style inconsistencies from design decision descriptions

- [x] Task 5: Implement Deviation Detection and Justification (AC: 4)
  - [x] Implement `_detect_pattern_deviations(violations: list[PatternViolation], decisions: list[DesignDecision]) -> list[PatternDeviation]`
  - [x] For each violation, check if decision rationale justifies the deviation
  - [x] Mark deviations as justified or unjustified based on rationale analysis
  - [x] Assign severity based on pattern type and deviation scope
  - [x] Generate recommendations for unjustified deviations

- [x] Task 6: Implement Pass/Fail Decision Logic (AC: 4, 7)
  - [x] Implement `_make_pattern_decision(violations: list[PatternViolation], deviations: list[PatternDeviation]) -> tuple[bool, float, list[str]]`
  - [x] Calculate confidence score based on pattern conformance percentage
  - [x] Apply configurable thresholds (via YoloConfig or defaults)
  - [x] Fail if any critical unjustified deviations exist
  - [x] Default thresholds: fail if confidence < 0.7 OR any critical unjustified deviation

- [x] Task 7: Implement LLM-Powered Pattern Analysis (AC: 6)
  - [x] Create `_analyze_patterns_with_llm(decisions: list[DesignDecision], patterns: list[CodePattern]) -> PatternMatchingResult | None`
  - [x] Design prompt template for pattern matching analysis
  - [x] Add tenacity @retry decorator with exponential backoff (3 attempts)
  - [x] Use configurable model via YOLO_LLM__ROUTINE_MODEL env var
  - [x] Implement graceful fallback to rule-based analysis on LLM failure
  - [x] Parse LLM JSON response to typed objects

- [x] Task 8: Create Main Pattern Matching Function (AC: 1, 5, 7)
  - [x] Create `run_pattern_matching(decisions: list[DesignDecision], pattern_store?: ChromaPatternStore, config?) -> PatternMatchingResult` async function
  - [x] Orchestrate pattern retrieval, checking, and deviation detection
  - [x] Calculate overall_pass and confidence score
  - [x] Generate summary text describing matching outcome
  - [x] Add structlog logging for pattern matching start/complete

- [x] Task 9: Integrate with architect_node (AC: 5)
  - [x] Update `architect_node` to call `run_pattern_matching` after ATAM review
  - [x] Add `pattern_matching` field to ArchitectOutput dataclass
  - [x] Include pattern matching summary in processing_notes
  - [x] Update ArchitectOutput.to_dict() to include pattern matching results
  - [x] Pass pattern store from state if available

- [x] Task 10: Write Unit Tests for Types (AC: 7)
  - [x] Test PatternViolation dataclass creation and to_dict()
  - [x] Test PatternDeviation dataclass creation and to_dict()
  - [x] Test PatternMatchingResult dataclass creation and to_dict()
  - [x] Test immutability of frozen dataclasses

- [x] Task 11: Write Unit Tests for Pattern Retrieval (AC: 1)
  - [x] Test pattern retrieval with mock ChromaPatternStore
  - [x] Test retrieval of each pattern type
  - [x] Test empty results when no patterns stored
  - [x] Test handling when pattern store is None

- [x] Task 12: Write Unit Tests for Naming Convention Checking (AC: 2)
  - [x] Test naming violation detection
  - [x] Test confidence score calculation
  - [x] Test no violations when patterns match
  - [x] Test multiple pattern types

- [x] Task 13: Write Unit Tests for Architectural Style Checking (AC: 3)
  - [x] Test structure pattern checking
  - [x] Test import style checking
  - [x] Test design pattern checking
  - [x] Test combined style inconsistencies

- [x] Task 14: Write Unit Tests for Deviation Detection (AC: 4)
  - [x] Test deviation detection from violations
  - [x] Test justification analysis from decision rationale
  - [x] Test severity assignment
  - [x] Test recommendation generation

- [x] Task 15: Write Unit Tests for Pass/Fail Decision (AC: 4, 7)
  - [x] Test pass decision with good conformance
  - [x] Test fail decision with critical deviations
  - [x] Test confidence score calculation
  - [x] Test threshold configuration

- [x] Task 16: Write Unit Tests for LLM Integration (AC: 6)
  - [x] Test LLM analysis with mocked LLM
  - [x] Test retry behavior on transient failures
  - [x] Test fallback to rule-based on LLM failure
  - [x] Test JSON parsing of LLM response

- [x] Task 17: Write Integration Tests (AC: 5)
  - [x] Test architect_node includes pattern_matching
  - [x] Test end-to-end flow with mock patterns and decisions
  - [x] Test integration with memory layer pattern store
  - [x] Test ArchitectOutput serialization with pattern matching results

## Dev Notes

### Architecture Compliance

- **ADR-001 (State Management):** Use frozen dataclasses for PatternViolation, PatternDeviation, PatternMatchingResult (internal state)
- **ADR-002 (Memory Persistence):** Use ChromaPatternStore from memory layer for pattern storage
- **ADR-003 (LLM Abstraction):** Use litellm for LLM calls with configurable model
- **ADR-005 (LangGraph Communication):** Return state update dict, don't mutate state directly
- **ADR-007 (Error Handling):** Use tenacity with exponential backoff for LLM calls
- **ARCH-QUALITY-5:** All I/O operations (LLM calls, pattern store queries) must be async/await
- **ARCH-QUALITY-6:** Use structlog for all logging
- **ARCH-QUALITY-7:** Full type annotations on all functions

### Memory Layer Integration (Epic 2)

This story leverages the pattern learning infrastructure from Epic 2:

| Module | Purpose | Usage in This Story |
|--------|---------|-------------------|
| `memory/patterns.py` | CodePattern, PatternType, PatternResult dataclasses | Source of pattern types and structures |
| `memory/pattern_store.py` | ChromaPatternStore class | Query learned patterns for matching |
| `memory/learning.py` | PatternLearner class | Patterns are learned externally; we consume them |
| `memory/__init__.py` | Public exports | Import CodePattern, PatternType, ChromaPatternStore |

### Pattern Types to Check

| PatternType | What It Checks | Example Violation |
|-------------|----------------|-------------------|
| NAMING_FUNCTION | Function naming (snake_case vs camelCase) | `getUserId` instead of `get_user_id` |
| NAMING_CLASS | Class naming (PascalCase) | `userManager` instead of `UserManager` |
| NAMING_VARIABLE | Variable naming | `userName` instead of `user_name` |
| NAMING_MODULE | Module/file naming | `UserHandler.py` instead of `user_handler.py` |
| STRUCTURE_DIRECTORY | Directory organization | Tests in wrong location |
| STRUCTURE_FILE | File organization | Missing `__init__.py` |
| IMPORT_STYLE | Import patterns (absolute vs relative) | Relative imports when project uses absolute |
| DESIGN_PATTERN | Design pattern consistency | Factory pattern where project uses Builder |

### Pass/Fail Decision Criteria

| Criterion | Pass Threshold | Fail Condition |
|-----------|----------------|----------------|
| Critical Unjustified Deviations | 0 | Any critical pattern deviation without justification |
| High Severity Violations | ≤ 3 | > 3 high-severity naming/structure violations |
| Pattern Conformance | ≥ 70% | < 70% patterns matched |
| Confidence Score | ≥ 0.7 | < 0.7 overall confidence |

### Integration with Prior Stories

This story builds on outputs from:

| Story | Output Used | Integration Point |
|-------|-------------|-------------------|
| 7.1 Architect Node | architect_node, ArchitectOutput | Integration point for new module |
| 7.7 ATAM Review | Execution order | Pattern matching runs after ATAM review |
| 2.6 Project Pattern Learning | ChromaPatternStore, CodePattern | Source of learned patterns |

### LLM Prompt Template (suggested)

```python
PATTERN_MATCHING_PROMPT = """Analyze the following design decisions against existing codebase patterns.

Design Decisions:
{design_decisions}

Learned Codebase Patterns:
{patterns}

For each design decision:
1. Check naming conventions against learned patterns
2. Check architectural style consistency
3. Identify any pattern deviations
4. For deviations, check if the decision rationale justifies them

Respond in JSON format:
{{
  "overall_pass": true/false,
  "confidence": 0.85,
  "patterns_checked": ["naming_function", "naming_class", "structure_directory"],
  "violations": [
    {{
      "pattern_type": "naming_function",
      "expected": "snake_case",
      "actual": "camelCase",
      "file_context": "src/myModule.py",
      "severity": "high"
    }}
  ],
  "deviations": [
    {{
      "pattern_type": "design_pattern",
      "standard_pattern": "Factory pattern",
      "proposed_pattern": "Builder pattern",
      "justification": "Builder provides better configuration flexibility",
      "is_justified": true,
      "severity": "medium"
    }}
  ],
  "recommendations": [
    "Consider renaming getUserData to get_user_data for consistency"
  ],
  "summary": "Design mostly conforms with 2 minor deviations justified"
}}
"""
```

### Project Structure Notes

- **New Module:** `src/yolo_developer/agents/architect/pattern_matcher.py`
- **Type Additions:** Add to `src/yolo_developer/agents/architect/types.py`
- **Test Location:** `tests/unit/agents/architect/test_pattern_matcher.py`

### Module Structure After This Story

```
src/yolo_developer/agents/architect/
├── __init__.py              # Add PatternMatchingResult, run_pattern_matching exports
├── types.py                 # Add PatternViolation, PatternDeviation, PatternMatchingResult
├── node.py                  # Update to integrate pattern matching after ATAM review
├── twelve_factor.py         # Existing 12-Factor analysis (Story 7.2)
├── adr_generator.py         # Existing ADR generation (Story 7.3)
├── quality_evaluator.py     # Existing quality evaluation (Story 7.4)
├── risk_identifier.py       # Existing risk identification (Story 7.5)
├── tech_stack_validator.py  # Existing tech stack validation (Story 7.6)
├── atam_reviewer.py         # Existing ATAM review (Story 7.7)
└── pattern_matcher.py       # NEW: Pattern matching to codebase
```

### Story Dependencies

- **Depends on:** Story 7.1 (architect_node, ArchitectOutput), Story 7.7 (execution order), Epic 2 (PatternLearner, ChromaPatternStore, CodePattern)
- **Enables:** Epic 8 (Dev Agent - will use patterns for code generation)
- **FR Covered:** FR56: Architect Agent can ensure design patterns match existing codebase conventions
- **Completes:** Epic 7 (Architect Agent - this is the final story)

### Previous Story Context (7.7)

From Story 7.7 implementation:
- `run_atam_review()` is async and returns ATAMReviewResult
- LLM integration uses pattern with @retry decorator and JSON parsing
- Pattern-based fallback when LLM fails
- Integration happens in architect_node after tech stack validation
- ATAM review is stored in `atam_reviews` dict in ArchitectOutput

Follow the same patterns for pattern matching. Execute after ATAM review in architect_node.

### Git Intelligence (Recent Commits)

Recent commit pattern: `feat: Implement X with code review fixes (Story X.X)`

Files from Story 7.7 to reference:
- `src/yolo_developer/agents/architect/atam_reviewer.py` - LLM integration pattern with fallback
- `src/yolo_developer/agents/architect/types.py` - Type definition patterns
- `src/yolo_developer/agents/architect/node.py` - Integration point for new modules
- `tests/unit/agents/architect/test_atam_reviewer.py` - Test patterns to follow

### Key Types From Prior Stories

```python
# From types.py - design decisions to analyze
DesignDecision:
    id: str
    story_id: str
    decision_type: DesignDecisionType
    description: str
    rationale: str
    alternatives_considered: tuple[str, ...]

# From memory/patterns.py - learned patterns to match against
CodePattern:
    pattern_type: PatternType
    name: str
    value: str
    confidence: float
    examples: tuple[str, ...]
    source_files: tuple[str, ...]

PatternType: Enum
    NAMING_FUNCTION, NAMING_CLASS, NAMING_VARIABLE, NAMING_MODULE
    STRUCTURE_DIRECTORY, STRUCTURE_FILE, IMPORT_STYLE, DESIGN_PATTERN
```

### Key Code Patterns from Prior Stories

```python
# Follow this pattern from atam_reviewer.py for LLM with fallback
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=10),
    reraise=True,
)
async def _analyze_patterns_with_llm(
    decisions: list[DesignDecision],
    patterns: list[CodePattern],
) -> PatternMatchingResult | None:
    """LLM-powered pattern analysis with retry."""
    try:
        # LLM call logic
        ...
    except Exception:
        logger.warning("llm_pattern_analysis_failed", exc_info=True)
        return None  # Fallback to rule-based

# Main function orchestrates LLM with fallback
async def run_pattern_matching(
    decisions: list[DesignDecision],
    pattern_store: ChromaPatternStore | None = None,
    config: YoloConfig | None = None,
) -> PatternMatchingResult:
    """Main entry point for pattern matching."""
    # Try LLM first
    llm_result = await _analyze_patterns_with_llm(decisions, patterns)
    if llm_result is not None:
        return llm_result

    # Fallback to rule-based
    return await _rule_based_pattern_matching(decisions, patterns)
```

### Consistency Rules to Enforce

Per Architecture Document (Implementation Patterns section):

1. **State field naming:** snake_case for all state dictionary keys
2. **Agent output format:** Return dict updates, never mutate state
3. **Async convention:** All agent nodes and I/O operations are async
4. **Retry pattern:** Use tenacity with consistent configuration
5. **Log message format:** Structured logging with structlog
6. **Type annotation patterns:** Full type hints, use `from __future__ import annotations`
7. **Import organization:** isort-compatible, grouped by type

### Epic 7 Completion Context

This is the **final story in Epic 7** (Architect Agent). Upon completion:

| Story | Status | Description |
|-------|--------|-------------|
| 7.1 | done | Create Architect Agent Node |
| 7.2 | done | 12-Factor Design Generation |
| 7.3 | done | ADR Generation |
| 7.4 | done | Quality Attribute Evaluation |
| 7.5 | done | Risk Identification |
| 7.6 | done | Tech Stack Constraint Design |
| 7.7 | done | ATAM Review |
| **7.8** | **ready-for-dev** | **Pattern Matching to Codebase** |

After this story:
- Epic 7 can be marked as "done"
- Sprint status should update epic-7 to done
- epic-7-retrospective becomes available
- Epic 8 (Dev Agent) becomes unblocked

### References

- [Source: _bmad-output/planning-artifacts/epics.md#Story-7.8] - Story definition
- [Source: _bmad-output/planning-artifacts/prd.md#FR56] - FR56: Pattern matching to codebase
- [Source: _bmad-output/planning-artifacts/architecture.md#Implementation-Patterns] - Consistency rules
- [Source: src/yolo_developer/memory/patterns.py] - CodePattern, PatternType definitions
- [Source: src/yolo_developer/memory/pattern_store.py] - ChromaPatternStore implementation
- [Source: src/yolo_developer/agents/architect/atam_reviewer.py] - LLM integration pattern to follow
- [Source: src/yolo_developer/agents/architect/types.py] - Type definitions to extend
- [Source: src/yolo_developer/agents/architect/node.py] - Current architect implementation
- [FR56: Architect Agent can ensure design patterns match existing codebase conventions]

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

N/A - No debug issues encountered during implementation.

### Completion Notes List

- All 17 tasks completed successfully following red-green-refactor TDD methodology
- 41 unit tests for pattern matching functionality (35 original + 6 from code review)
- Pattern matching integrated into architect_node after ATAM review step
- Epic 7 (Architect Agent) completed with this story
- Total architect module test count: 436 tests passing

### Code Review Fixes Applied

- Fixed ruff linting errors (unused imports, import sorting) in test file
- Added File List entry for sprint-status.yaml modification
- Added 2 tests for LLM fallback behavior (AC6 verification)
- Added 2 tests for naming convention checking with actual patterns (AC2)
- Added 2 tests for architectural style checking with actual patterns (AC3)

### File List

**New Files Created:**
- `src/yolo_developer/agents/architect/pattern_matcher.py` - Pattern matching implementation
- `tests/unit/agents/architect/test_pattern_matcher.py` - Pattern matcher unit tests

**Files Modified:**
- `src/yolo_developer/agents/architect/types.py` - Added PatternViolation, PatternDeviation, PatternMatchingResult, PatternCheckSeverity
- `src/yolo_developer/agents/architect/__init__.py` - Added exports for new types and run_pattern_matching
- `src/yolo_developer/agents/architect/node.py` - Integrated pattern matching after ATAM review
- `_bmad-output/implementation-artifacts/sprint-status.yaml` - Updated story and epic status to done
