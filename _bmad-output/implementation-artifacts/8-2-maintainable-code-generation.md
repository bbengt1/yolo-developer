# Story 8.2: Maintainable Code Generation

Status: done

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a developer,
I want generated code prioritizing maintainability,
So that future changes are easy.

## Acceptance Criteria

1. **AC1: Maintainability-First Hierarchy**
   - **Given** a story to implement
   - **When** code is generated by the Dev agent
   - **Then** it follows a maintainability-first hierarchy:
     - Readability over cleverness
     - Explicit over implicit
     - Simple over complex
     - Small, focused functions (< 50 lines)
   - **And** cyclomatic complexity is kept low (< 10 per function)

2. **AC2: Clear and Descriptive Naming**
   - **Given** generated code
   - **When** examining variable/function/class names
   - **Then** names clearly describe their purpose
   - **And** names use snake_case for functions and variables (per architecture)
   - **And** names use PascalCase for classes (per architecture)
   - **And** no single-letter variables except standard iterators (i, j, k in loops)

3. **AC3: Small and Focused Functions**
   - **Given** implementation requirements
   - **When** code is generated
   - **Then** each function has a single responsibility
   - **And** functions are small and focused (generally < 50 lines)
   - **And** deeply nested code is avoided (max 3 levels)
   - **And** complex logic is broken into helper functions

4. **AC4: Complexity Minimization**
   - **Given** a problem with multiple solution approaches
   - **When** implementation is generated
   - **Then** the simplest correct solution is chosen
   - **And** premature optimization is avoided
   - **And** YAGNI principle is followed (don't add features not in requirements)

5. **AC5: LLM Integration for Code Generation**
   - **Given** stories with architectural designs in state
   - **When** dev_node processes them
   - **Then** LLM is called to generate actual implementation code
   - **And** LLM calls use tenacity retry with exponential backoff
   - **And** LLM tier is "complex" for code generation (per ADR-003)
   - **And** generated code is validated for syntax before returning

6. **AC6: Prompt Engineering for Maintainability**
   - **Given** code generation prompts
   - **When** prompts are constructed for LLM
   - **Then** prompts explicitly include maintainability guidelines
   - **And** prompts include project conventions from architecture
   - **And** prompts include existing code patterns when available
   - **And** prompts request type annotations on all functions

## Tasks / Subtasks

- [x] Task 1: Create LLM Prompt Templates for Code Generation (AC: 6)
  - [x] Create `src/yolo_developer/agents/dev/prompts/` directory structure
  - [x] Create `code_generation.py` with base code generation prompt
  - [x] Include maintainability guidelines in prompt template
  - [x] Include project conventions (snake_case, type hints, async patterns)
  - [x] Include YAGNI and simplicity principles in prompt

- [x] Task 2: Implement LLM Code Generation Function (AC: 5, 6)
  - [x] Create `_generate_code_with_llm(story, design, context) -> CodeFile`
  - [x] Integrate with LLMRouter (import from `yolo_developer.llm.router`)
  - [x] Use "complex" tier for code generation per ADR-003
  - [x] Apply tenacity @retry decorator for resilience
  - [x] Include story requirements, AC, and design decisions in prompt

- [x] Task 3: Implement Code Syntax Validation (AC: 5)
  - [x] Create `_validate_python_syntax(code: str) -> tuple[bool, str | None]`
  - [x] Use Python's `ast.parse()` for syntax validation
  - [x] Return validation result and error message if any
  - [x] Handle edge cases (empty code, non-Python content)

- [x] Task 4: Update `_generate_implementation` to Use LLM (AC: 1, 2, 3, 4, 5)
  - [x] Replace stub implementation with LLM-powered generation
  - [x] Pass story details, design decisions, and context to LLM
  - [x] Validate generated code syntax before creating CodeFile
  - [x] Retry with modified prompt if syntax validation fails
  - [x] Fall back to stub if LLM fails after retries

- [x] Task 5: Implement Maintainability Guidelines Enforcement (AC: 1, 2, 3, 4)
  - [x] Create `_check_maintainability(code: str) -> list[str]`
  - [x] Check function length (warn if > 50 lines)
  - [x] Check for deep nesting (warn if > 3 levels)
  - [x] Check naming conventions (snake_case, descriptive)
  - [x] Return list of warnings (non-blocking)

- [x] Task 6: Add Project Context Extraction (AC: 6)
  - [x] Create `_extract_project_context(state) -> dict`
  - [x] Extract patterns from memory store if available
  - [x] Extract conventions from config
  - [x] Include architecture constraints from state

- [x] Task 7: Write Unit Tests for Prompt Templates (AC: 6)
  - [x] Test prompt template rendering with variables
  - [x] Test that maintainability guidelines are included
  - [x] Test that project conventions are included
  - [x] Test prompt structure follows expected format

- [x] Task 8: Write Unit Tests for LLM Code Generation (AC: 5)
  - [x] Test LLM integration with mock responses
  - [x] Test retry behavior on transient failures
  - [x] Test fallback to stub on persistent failures
  - [x] Test syntax validation of generated code

- [x] Task 9: Write Unit Tests for Maintainability Checks (AC: 1, 2, 3, 4)
  - [x] Test function length detection
  - [x] Test nesting depth detection
  - [x] Test naming convention checks
  - [x] Test combined maintainability scoring

- [x] Task 10: Write Integration Tests (AC: 5, 6)
  - [x] Test full code generation flow with mocked LLM
  - [x] Test context extraction and prompt construction
  - [x] Test end-to-end story to code generation

## Dev Notes

### Architecture Compliance

- **ADR-001 (State Management):** Continue using frozen dataclasses for CodeFile, TestFile
- **ADR-003 (LLM Provider):** Use LLMRouter with "complex" tier for code generation
- **ADR-005 (LangGraph Communication):** Return state update dict from dev_node
- **ADR-006 (Quality Gates):** DoD gate already integrated (Story 8.1)
- **ADR-007 (Error Handling):** Use tenacity for LLM retries
- **ARCH-QUALITY-6:** Use structlog for all logging
- **ARCH-QUALITY-7:** Full type annotations on all functions

### Technical Requirements

- Use `from __future__ import annotations` in all new files
- Use snake_case for all function names and variables
- Follow existing patterns from `agents/dev/node.py` (Story 8.1)
- All dataclasses should be frozen (immutable)
- Use tenacity @retry decorator with exponential backoff for LLM calls

### Library Versions (from architecture.md)

| Library | Version | Purpose |
|---------|---------|---------|
| LangGraph | 1.0.5 | Orchestration framework |
| structlog | latest | Structured logging |
| tenacity | latest | Retry with backoff |
| LiteLLM | latest | Multi-provider LLM abstraction |

### LLM Router Usage Pattern

```python
from yolo_developer.llm.router import LLMRouter

# Initialize router (usually injected)
router = LLMRouter(config)

# Use "complex" tier for code generation
response = await router.call(
    messages=[{"role": "user", "content": prompt}],
    tier="complex"  # Uses premium model per ADR-003
)
```

### Maintainability-First Hierarchy

The Dev agent MUST prioritize code quality in this order:

1. **Readability** - Code should be immediately understandable
2. **Simplicity** - Avoid unnecessary complexity
3. **Maintainability** - Easy to modify and extend
4. **Performance** - Only optimize when measurably needed

### Code Generation Prompt Structure

```python
PROMPT_TEMPLATE = """
Generate Python code for the following story:

Story: {story_title}
Requirements: {requirements}
Acceptance Criteria: {acceptance_criteria}

Design Decisions:
{design_decisions}

Project Conventions:
- Use snake_case for functions and variables
- Use PascalCase for classes
- Full type annotations required
- Use async/await for I/O operations
- Follow YAGNI principle

Maintainability Guidelines:
- Keep functions under 50 lines
- Maximum nesting depth: 3 levels
- Clear, descriptive variable names
- Single responsibility per function
- Avoid premature optimization

Generate clean, maintainable Python code that implements the requirements.
Include docstrings and type hints.
"""
```

### Project Structure Notes

- **Prompt Templates:** `src/yolo_developer/agents/dev/prompts/`
- **LLM Router:** `src/yolo_developer/llm/router.py` (existing)
- **Node Function:** `src/yolo_developer/agents/dev/node.py` (modify)
- **Test Location:** `tests/unit/agents/dev/`

### Previous Story Learnings Applied (Story 8.1)

From Story 8.1 implementation:
- dev_node returns state updates only (messages, decisions, dev_output)
- Story extraction supports architect_output, pm_output, and messages
- CodeFile and TestFile dataclasses with to_dict() method
- Quality gate decorator @quality_gate("definition_of_done")
- Tenacity @retry decorator for async resilience

### Git Commit Pattern (from recent commits)

Recent commits follow pattern:
```
feat: Implement <feature> with code review fixes (Story X.Y)
```

### Existing Dev Module Structure

```
src/yolo_developer/agents/dev/
├── __init__.py         # Exports: dev_node, DevOutput, ImplementationArtifact, CodeFile, TestFile
├── types.py            # Type definitions (CodeFile, TestFile, ImplementationArtifact, DevOutput)
├── node.py             # dev_node function and helpers (MODIFY)
└── prompts/            # NEW: Prompt templates
    ├── __init__.py
    └── code_generation.py
```

### Key Imports for Implementation

```python
from __future__ import annotations

from typing import Any

import structlog
from tenacity import retry, stop_after_attempt, wait_exponential

from yolo_developer.agents.dev.types import CodeFile, DevOutput, ImplementationArtifact
from yolo_developer.llm.router import LLMRouter
from yolo_developer.gates import quality_gate
from yolo_developer.orchestrator.context import Decision
from yolo_developer.orchestrator.state import YoloState, create_agent_message

logger = structlog.get_logger(__name__)
```

### LLM Response Parsing

Generated code should be extracted from LLM response using:
```python
def _extract_code_from_response(response: str) -> str:
    """Extract Python code from LLM response.

    Handles responses with:
    - Code in ```python ... ``` blocks
    - Code in ``` ... ``` blocks
    - Raw code without blocks
    """
    # Implementation extracts code block content
    ...
```

### Syntax Validation Pattern

```python
import ast

def _validate_python_syntax(code: str) -> tuple[bool, str | None]:
    """Validate Python code syntax.

    Returns:
        Tuple of (is_valid, error_message).
        error_message is None if valid.
    """
    try:
        ast.parse(code)
        return True, None
    except SyntaxError as e:
        return False, f"Line {e.lineno}: {e.msg}"
```

### Story Dependencies

This story builds on:
- Story 8.1 (Create Dev Agent Node) - foundation for this story

This story enables:
- Story 8.3 (Unit Test Generation) - tests for generated code
- Story 8.4 (Integration Test Generation) - cross-component tests
- Story 8.5 (Documentation Generation) - code documentation
- Story 8.7 (Pattern Following) - pattern-aware code generation

### Functional Requirements Addressed

| FR | Description | How Addressed |
|----|-------------|---------------|
| FR57 | Dev Agent can implement code following maintainability-first hierarchy | LLM-powered code generation with maintainability prompts |

### References

- [Source: _bmad-output/planning-artifacts/epics.md#Epic-8] - Epic definition
- [Source: _bmad-output/planning-artifacts/epics.md#Story-8.2] - Story definition
- [Source: _bmad-output/planning-artifacts/architecture.md#ADR-003] - LLM provider abstraction
- [Source: _bmad-output/planning-artifacts/architecture.md#ADR-007] - Error handling patterns
- [Source: src/yolo_developer/agents/dev/node.py] - Existing dev node (Story 8.1)
- [Source: src/yolo_developer/agents/dev/types.py] - Dev type definitions
- [Source: _bmad-output/implementation-artifacts/8-1-create-dev-agent-node.md] - Previous story learnings
- [FR57: Dev Agent can implement code following maintainability-first hierarchy]

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

### Completion Notes List

- Implemented LLM-powered code generation with maintainability-first prompt templates
- Created LLMRouter class with tenacity retry and tier-based model selection
- Implemented syntax validation using Python's ast.parse()
- Added maintainability checking (function length, nesting depth, naming conventions)
- Updated _generate_implementation to use LLM with fallback to stub
- Created _extract_project_context for architecture patterns and conventions
- All 189 tests pass (43 prompt tests, 34 code utils tests, 22 router tests, 13 implementation tests, 11 integration tests)
- Full type checking passes with mypy
- Linting passes with ruff

**Code Review Fixes (2026-01-11):**
- Added cyclomatic complexity checking to enforce AC1 (< 10 per function)
- Exported build_retry_prompt from prompts/__init__.py for API consistency
- Added _reset_llm_router() function for testing global state
- Added 13 new tests: 8 for cyclomatic complexity, 4 for generate_code_with_validation, 1 for ImportError
- Total tests now: 202 passing

### Change Log

- 2026-01-11: Implemented Story 8.2 - Maintainable Code Generation
- 2026-01-11: Code review fixes - added cyclomatic complexity checking, exported build_retry_prompt, added 13 tests

### File List

**New Files:**
- src/yolo_developer/agents/dev/prompts/__init__.py
- src/yolo_developer/agents/dev/prompts/code_generation.py
- src/yolo_developer/agents/dev/code_utils.py
- src/yolo_developer/llm/router.py
- tests/unit/agents/dev/prompts/__init__.py
- tests/unit/agents/dev/prompts/test_code_generation.py
- tests/unit/agents/dev/test_code_utils.py
- tests/unit/llm/__init__.py
- tests/unit/llm/test_router.py
- tests/integration/agents/dev/__init__.py
- tests/integration/agents/dev/test_code_generation_integration.py

**Modified Files:**
- src/yolo_developer/llm/__init__.py
- src/yolo_developer/agents/dev/node.py
- src/yolo_developer/agents/dev/types.py (formatting only)
- tests/unit/agents/dev/test_implementation.py
